1. console.log(2.0 == “2” == new Boolean(true) == “1”) . Answer - true

2. Hoisting: is a Javascript mechanism where all the variables and function declarations are moved to the top of their scope regardless where they are defined or executed.
    Inevitably, this means that no matter where functions and variables are declared, they are moved to the top of their scope regardless of whether their scope is global or local.
        
        console.log(variable); // Output: ReferenceError: variable is not defined
    In JavaScript, a ReferenceError is thrown when trying to access a previously undeclared variable.

    Lifecycle of a variable: Decalaration -> Assignment -> Usage

    However, since JavaScript allows us to both declare and initialise our variables simultaneously, this is the most used pattern:
    var a = 100;

    Variable declarations are processed before any code is executed.

    All undeclared variables are global variables.
        Eg: function hoist() {
                a = 20;
                var b = 100;
            }

            hoist();

            console.log(a); 
            /* 
            Accessible as a global variable outside hoist() function
            Output: 20
            */

            console.log(b); 
            /*
            Since it was declared, it is confined to the hoist() function scope.
            We can't print it out outside the confines of the hoist() function.
            Output: ReferenceError: b is not defined
            */

    Since this is one of the eccentricities of how JavaScript handles variables, it is recommended to always declare variables regardless of whether they are in a function or global scope. This clearly delineates how the interpreter should handle them at run time.

    Function scoped variables:
        Eg: function hoist() {
                console.log(message);
                var message='Hoisting is all the rage!'
            }

            hoist();        //undefined

    Using strict mode nullifies hoisting and gives a ReferenceError

    If we use let or const then also ReferenceError will be given rather than undefined

    In es6 the constant variable must be both initialised and declared before accessing it otherwise following error occurs.
        Eg: const PI;
            console.log(PI); // Ouput: SyntaxError: Missing initializer in const declaration
            PI=3.142;

    For function hoisting, functions can be loosely classified into 2 categories: Function declarations & function expressions
        i) function declaration hoisting:
            Eg: hoisted(); // Output: "This function has been hoisted."
                function hoisted() {
                    console.log('This function has been hoisted.');
                };

        ii) function expression hoisting: these are not hoisted
            Eg: expression(); //Output: "TypeError: expression is not a function
                var expression = function() {
                    console.log('Will this work?');
                };

        iii) Combination declaration & expression: these are also not hoisted
            Eg: expression(); // Ouput: TypeError: expression is not a function
                var expression = function hoisting() {
                    console.log('Will this work?');
                };

    Order of Precedence:
        1. Variable assignment takes precedence over function declaration
        2. Function declarations take precedence over variable declarations

        Variable assignment over function declaration
            var double = 22;

            function double(num) {
                return (num*2);
            }

            console.log(typeof double); // Output: number

        Function declarations over variable declarations
            var double;

            function double(num) {
                return (num*2);
            }

            console.log(typeof double); // Output: function

    Hoisting Classes: Classes in javascript can be loosely classified into Class declarations & Class expressions
        It is important to declare a class before we can use it

        Eg: Class declarations
            var Frodo = new Hobbit();
            Frodo.height = 100;
            Frodo.weight = 300;
            console.log(Frodo); // Output: ReferenceError: Hobbit is not defined

            class Hobbit {
                constructor(height, weight) {
                    this.height = height;
                    this.weight = weight;
                }
            }

            I'm sure you've noticed that instead of getting an undefined we get a Reference error. That evidence lends claim to our position that class declarations are hoisted.

        Eg: Class expressions. Class expressions are not hoisted
            var Square = new Polygon();
            Square.height = 10;
            Square.width = 10;
            console.log(Square); // Output: TypeError: Polygon is not a constructor

            var Polygon = class {
                constructor(height, width) {
                    this.height = height;
                    this.width = width;
                }
            };

3. Lexical Scoping: defines how variable names are resolved inside a nested function. The inner functions contains the scope of the parent functions even if the parent function has returned.

4. Arguments: array like object which has length property but not any other array properties.
    Eg: function func1(a, b, c) {
        console.log(arguments[0]);
        // expected output: 1

        console.log(arguments[1]);
        // expected output: 2

        console.log(arguments[2]);
        // expected output: 3
        }

        func1(1, 2, 3);

    For example, if a function is passed 3 arguments, you can access them as follows:
        arguments[0] // first argument
        arguments[1] // second argument
        arguments[2] // third argument

    Each argument can also be set or reassigned:
        arguments[1] = 'new value';

    To convert it to an Array following properties can be used:

        var args = Array.prototype.slice.call(arguments);
        // Using an array literal is shorter than above but allocates an empty array
        var args = [].slice.call(arguments);
        let args = Array.from(arguments);
        // or
        let args = [...arguments];

    Arguments is useful when the function can accept more arguments than it was defined for.
        Eg: function longestString() {
                var longest = '';
                for (var i=0; i < arguments.length; i++) {
                    if (arguments[i].length > longest.length) {
                        longest = arguments[i];
                    }
                }
                return longest;
            }
    
    Using typeof with arguments:
        console.log(typeof arguments); // 'object' 
        console.log(typeof arguments[0]); // returns the type of the first argument

    Properties:
        arguments.callee
            Reference to the currently executing function that the arguments belong to.
        arguments.length
            The number of arguments that were passed to the function.
        arguments[@@iterator]
            Returns a new Array iterator object that contains the values for each index in arguments.

    
    Examples:
        i) Concatenation of strings
            function myConcat(separator) {
                let args = Array.prototype.slice.call(arguments, 1);
                return args.join(separator);
            }
            // returns "red, orange, blue"
            myConcat(', ', 'red', 'orange', 'blue');

            // returns "elephant; giraffe; lion; cheetah"
            myConcat('; ', 'elephant', 'giraffe', 'lion', 'cheetah');

            // returns "sage. basil. oregano. pepper. parsley"
            myConcat('. ', 'sage', 'basil', 'oregano', 'pepper', 'parsley');
        ii) Defining a function that creates HTML Lists:
            function list(type) {
                var html = '<' + type + 'l><li>';
                var args = Array.prototype.slice.call(arguments, 1);
                html += args.join('</li><li>');
                html += '</li></' + type + 'l>'; // end list

                return html;
            }

            let listHTML = list('u', 'One', 'Two', 'Three');
            /* listHTML is:
            "<ul><li>One</li><li>Two</li><li>Three</li></ul>"
            */
        iii) Rest, default and destructured parameters:
            In strict mode: these have no effect on argument object.
            In non-strict mode: If rest parameters are not present then any change in function will change the value of arguments object.
                Eg: function func(a) { 
                        arguments[0] = 99; // updating arguments[0] also updates a
                        console.log(a);
                    }
                    func(10); // 99
                    
                        And also:
                    
                    function func(a) { 
                        a = 99; // updating a also updates arguments[0]
                        console.log(arguments[0]);
                    }
                    func(10); // 99
            
            If rest parameters are present then the value of argument object will retain to the original which was sent to the function.
                Eg: function func(a = 55) { 
                        arguments[0] = 99; // updating arguments[0] does not also update a
                        console.log(a);
                    }
                    func(10); // 10
                    
                    And also:

                    function func(a = 55) { 
                        a = 99; // updating a does not also update arguments[0]
                        console.log(arguments[0]);
                    }
                    func(10); // 10
                    
                    And also:

                    // An untracked default parameter
                    function func(a = 55) { 
                        console.log(arguments[0]);
                    }
                    func(); // undefined

5. Super: used to call parents methods and functions.
    Eg: super([arguments]); // calls the parent constructor.
        super.functionOnParent([arguments]);

    When used in a constructor, the super keyword appears alone and must be used before the this keyword is used. The super keyword can also be used to call functions on a parent object.

    Examples:
        i) Using super in classes:
            class Rectangle {
                constructor(height, width) {
                    this.name = 'Rectangle';
                    this.height = height;
                    this.width = width;
                }
                sayName() {
                    console.log('Hi, I am a ', this.name + '.');
                }
                get area() {
                    return this.height * this.width;
                }
                set area(value) {
                    this._area = value;
                }
            }

            class Square extends Rectangle {
                constructor(length) {
                    this.height; // ReferenceError, super needs to be called first!

                    // Here, it calls the parent class's constructor with lengths
                    // provided for the Rectangle's width and height
                    super(length, length);

                    // Note: In derived classes, super() must be called before you
                    // can use 'this'. Leaving this out will cause a reference error.
                    this.name = 'Square';
                }
            }
        
        ii) Super calling static methods:
            Eg: class Rectangle {
                    constructor() {}
                    static logNbSides() {
                        return 'I have 4 sides';
                    }
                }

                class Square extends Rectangle {
                    constructor() {}
                    static logDescription() {
                        return super.logNbSides() + ' which are all equal';
                    }
                }
                Square.logDescription(); // 'I have 4 sides which are all equal'

        iii) Deleting super properties will throw an error:
            Eg: class Base {
                    constructor() {}
                    foo() {}
                }
                class Derived extends Base {
                    constructor() {}
                    delete() {
                        delete super.foo; // this is bad
                    }
                }
            
        iv) super.prop cannot overwrite the non-writable properties:
            Eg: class X {
                    constructor() {
                        Object.defineProperty(this, 'prop', {
                            configurable: true,
                            writable: false, 
                            value: 1
                        });
                    }
                }

                class Y extends X {
                    constructor() {
                        super();
                    }
                    foo() {
                        super.prop = 2;   // Cannot overwrite the value.
                    }
                }

                var y = new Y();
                y.foo(); // TypeError: "prop" is read-only
                console.log(y.prop); // 1

                new Derived().delete(); // ReferenceError: invalid delete involving 'super'.

        v) super.prop in object literals: Super can also be used in the object initializer / literal notation. In this example, two objects define a method. In the second object, super calls the first object's method. This works with the help of Object.setPrototypeOf() with which we are able to set the prototype of obj2 to obj1, so that super is able to find method1 on obj1.
            Eg: var obj1 = {
                    method1() {
                        console.log('method 1');
                    }
                }

                var obj2 = {
                    method2() {
                        super.method1();
                    }
                }

                Object.setPrototypeOf(obj2, obj1);
                obj2.method2(); // logs "method 1"

6. new.target: in functions or constructors which are invoked using the new object it returns a reference to function or the constructor. For normal functions new.target is undefined.
    Eg: function Foo() {
            if (!new.target) throw 'Foo() must be called with new';
        }

        try {
            Foo();
        }
        catch(e) {
            console.log(e);
            // expected output: "Foo() must be called with new"
        }

    In arrow functions, new.target are inherited from the surrounding scope.

    Examples:
        i) new.target in function calls
            function Foo() {
                if (!new.target) { throw 'Foo() must be called with new' }
                console.log('Foo instantiated with new')
            }

            new Foo()  // logs "Foo instantiated with new"
            Foo()      // throws "Foo() must be called with new"
        
        ii) new.target in constructors
            class A {
                constructor() {
                    console.log(new.target.name)
                }
            }

            class B extends A { constructor() { super() } }

            let a = new A()  // logs "A"
            let b = new B()  // logs "B"

            class C { constructor() { console.log(new.target)  } }
            class D extends C { constructor() { super()  } }
            
            let c = new C()  // logs class C{constructor(){console.log(new.target);}}
            let d = new D()  // logs class D extends C{constructor(){super();}}

7. call(): calls a function with a given this value and arguments individually
    Eg: function Product(name, price) {
            this.name = name;
            this.price = price;
        }

        function Food(name, price) {
            Product.call(this, name, price);
            this.category = 'food';
        }

        console.log(new Food('cheese', 5).name);
        // expected output: "cheese"

    With call() you can write a method once and inherit it in another object.
    Examples:
        i) Using call() to chain constructors for an object:
            function Product(name, price) {
                this.name = name;
                this.price = price;
            }

            function Food(name, price) {
                Product.call(this, name, price);
                this.category = 'food';
            }

            function Toy(name, price) {
                Product.call(this, name, price);
                this.category = 'toy';
            }

            const cheese = new Food('feta', 5);
            const fun = new Toy('robot', 40);

        ii) Using call to invoke anonymous functions:
            const animals = [
                { species: 'Lion', name: 'King' },
                { species: 'Whale', name: 'Fail' }
            ];

            for (let i = 0; i < animals.length; i++) {
                (function(i) {
                    this.print = function() {
                    console.log('#' + i + ' ' + this.species
                                + ': ' + this.name);
                    }
                    this.print();
                }).call(animals[i], i);
            }

        iii) Using call to invoke a function and specifying the context for this:
            Eg: function greet() {
                    const reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' ');
                    console.log(reply);
                }

                const obj = {
                    animal: 'cats', sleepDuration: '12 and 16 hours'
                };

                greet.call(obj);  // cats typically sleep between 12 and 16 hours
        
        iv) Using call to invoke a function without specifying the first argument: If the first argument is not mentioned then value of this is bounded to the global object.
            var sData = 'Wisen';
            function display() {
                console.log('sData value is %s ', this.sData);
            }

            display.call();  // sData value is Wisen

            ------
            Caution: In strict mode, the value of this will be undefined. See below.
            -----
            'use strict';

            var sData = 'Wisen';

            function display() {
            console.log('sData value is %s ', this.sData);
            }

            display.call(); // Cannot read the property of 'sData' of undefined

8. apply(): calls a function with a given this value and array of arguments.
    Note: The main difference between call() and apply() is that call() accepts a list of arguments and apply accepts a single array of arguments.

    When the first argument is undefined or null a similar outcome can be achieved using the array spread syntax.
    Eg: const numbers = [5, 6, 2, 3, 7];
        const max = Math.max.apply(null, numbers);
        console.log(max);
        // expected output: 7
        const min = Math.min.apply(null, numbers);
        console.log(min);
        // expected output: 2

    this argument is required. In non-strict mode the null or undefined value will get replaced with this of the global object.

    Examples:
        i) Using apply to append to another array:
            const array = ['a', 'b'];
            const elements = [0, 1, 2];
            array.push.apply(array, elements);
            console.info(array); // ["a", "b", 0, 1, 2]

        ii) Using apply and built-in functions:
            // min/max number in an array
            const numbers = [5, 6, 2, 3, 7];

            // using Math.min/Math.max apply
            let max = Math.max.apply(null, numbers); 
            // This about equal to Math.max(numbers[0], ...)
            // or Math.max(5, 6, ...)

            let min = Math.min.apply(null, numbers);

            // vs. simple loop based algorithm
            max = -Infinity, min = +Infinity;

            for (let i = 0; i < numbers.length; i++) {
                if (numbers[i] > max) {
                    max = numbers[i];
                }
                if (numbers[i] < min) {
                    min = numbers[i];
                }
            }
        
            But beware: by using apply this way, you run the risk of exceeding the JavaScript engine's argument length limit. The consequences of applying a function with too many arguments (that is, more than tens of thousands of arguments) varies across engines.
            If your value array might grow into the tens of thousands, use a hybrid strategy: apply your function to chunks of the array at a time:

            function minOfArray(arr) {
                let min = Infinity;
                let QUANTUM = 32768;

                for (var i = 0, len = arr.length; i < len; i += QUANTUM) {
                    var submin = Math.min.apply(null, arr.slice(i, Math.min(i+QUANTUM, len)));
                    min = Math.min(submin, min);
                }

                return min;
            }

            let min = minOfArray([5, 6, 2, 3, 7]);

        iii) Using apply to chain constructors: In the following example we will create a global Function method called construct, which will enable you to use an array-like object with a constructor instead of an arguments list.
                Function.prototype.construct = function(aArgs) {
                    let oNew = Object.create(this.prototype);
                    this.apply(oNew, aArgs);
                    return oNew;
                };

                function MyConstructor() {
                    for (let nProp = 0; nProp < arguments.length; nProp++) {
                        this['property' + nProp] = arguments[nProp];
                    }
                }

                let myArray = [4, 'Hello world!', false];
                let myInstance = MyConstructor.construct(myArray);

                console.log(myInstance.property1);                // logs 'Hello world!'
                console.log(myInstance instanceof MyConstructor); // logs 'true'
                console.log(myInstance.constructor);              // logs 'MyConstructor'

9. bind(): bind creates a new function that when called bind this object to the provided value.
    Eg: const module = {
            x: 42,
            getX: function() {
                return this.x;
            }
        }
        const unboundGetX = module.getX;
        console.log(unboundGetX()); // The function gets invoked at the global scope
        // expected output: undefined

        const boundGetX = unboundGetX.bind(module);
        console.log(boundGetX());
        // expected output: 42

    Examples:
        i) Creating a bound function:
            this.x = 9;    // 'this' refers to global 'window' object here in a browser
            const module = {
                x: 81,
                getX: function() { return this.x; }
            };

            module.getX(); 
            //  returns 81

            const retrieveX = module.getX;
            retrieveX();
            //  returns 9; the function gets invoked at the global scope

            //  Create a new function with 'this' bound to module
            //  New programmers might confuse the
            //  global variable 'x' with module's property 'x'
            const boundGetX = retrieveX.bind(module);
            boundGetX(); 
            //  returns 81

        ii) Partially applied function:
            function list() {
                return Array.prototype.slice.call(arguments);
            }

            function addArguments(arg1, arg2) {
                return arg1 + arg2
            }

            const list1 = list(1, 2, 3);
            //  [1, 2, 3]

            const result1 = addArguments(1, 2);
            //  3

            // Create a function with a preset leading argument
            const leadingThirtysevenList = list.bind(null, 37);

            // Create a function with a preset first argument.
            const addThirtySeven = addArguments.bind(null, 37); 

            const list2 = leadingThirtysevenList(); 
            //  [37]

            const list3 = leadingThirtysevenList(1, 2, 3); 
            //  [37, 1, 2, 3]

            const result2 = addThirtySeven(5); 
            //  37 + 5 = 42 

            const result3 = addThirtySeven(5, 10);
            //  37 + 5 = 42 
            //  (the second argument is ignored)

        iii) With setTimeout():
            function LateBloomer() {
                this.petalCount = Math.floor(Math.random() * 12) + 1;
            }

            // Declare bloom after a delay of 1 second
            LateBloomer.prototype.bloom = function() {
                window.setTimeout(this.declare.bind(this), 1000);
            };

            LateBloomer.prototype.declare = function() {
                console.log(`I am a beautiful flower with ${this.petalCount} petals!`);
            };

            const flower = new LateBloomer();
            flower.bloom();  
            //  after 1 second, calls 'flower.declare()'

        iv) Creating shortcuts:
            const unboundSlice = Array.prototype.slice;
            const slice = Function.prototype.apply.bind(unboundSlice);

            // ...

            slice(arguments);

10. Strict Mode: Introduced in ECMAScript 5 is a way to opt into restricted variant of Javascript, i.e. implicitly opting out of the sloppy mode. Strict mode behaves differently than the code without strict mode and also not every browser supports strict mode. So it is important to feature test the code which is in strict mode. Strict mode and non-strict mode can coexist. It intentionally has different semantics than the normal code. Strict mode provides the following changes to Javascript semantics:
    i) Eliminates some Javascript silent errors by converting them to throw expressions.
    ii) Optimise some code which is very difficult for Javascript engine to optimize. Sometimes strict mode code is faster than the non-strict mode code.
    iii) Prohibits some syntax which might be introduced in the next ECMAScripts.

    Invoking strict mode: Strict mode can only be applied to entire scripts or functions. They are not applied to block statements ({}) or somehow implementing them in block statements will do nothing.
        i) Strict mode for scripts: // Whole-script strict mode syntax
                                    'use strict';
                                    var v = "Hi! I'm a strict mode script!";
            It isn't possible to blindly concatenate the conflicting scripts. You concatenate strict mode script with non-script mode, the entire concatenatin looks strict. Inverse is also true, you try to concatenate non-strict mode with strict mode, the entire concatenation looks non-strict. But if you must, consider using strict mode in function by function basis.
        ii) Strict mode for functions:  function strict() {
                                        // Function-level strict mode syntax
                                        'use strict';
                                        function nested() { return 'And so am I!'; }
                                        return "Hi!  I'm a strict mode function!  " + nested();
                                        }
                                        function notStrict() { return "I'm not strict."; }
        iii) Strict mode for Javascript modules: ECMAScript 2015 introduced JavaScript modules and therefore a 3rd way to enter strict mode. The entire contents of JavaScript modules are automatically in strict mode, with no statement needed to initiate it.
                function strict() {
                    // because this is a module, I'm strict by default
                }
                export default strict;

    Changes in strict mode: Strict mode changes both syntax and runtime behaviour
        * Converting mistakes into errors:
            i) Strict mode makes it impossible to accidentally create global variables. For eg: If a global variable is declared and then it is mistyped somewhere while assignment, then without using strict mode Javascript will create its new property in Global object. But with strict it will throw error.
                Eg: 'use strict';
                                        // Assuming no global variable mistypedVariable exists
                    mistypeVariable = 17;  // this line throws a ReferenceError due to the 
                                        // misspelling of variable
            ii) Strict mode does not allow to use keywords as variable name like undefined, Infinity, NaN etc. Also it throws error when doing assignment to non-writable object, assignment to a getter only property, assignment to a new property on a non-extensible object.
                Eg: 'use strict';
                    // Assignment to a non-writable global
                    var undefined = 5; // throws a TypeError
                    var Infinity = 5; // throws a TypeError

                    // Assignment to a non-writable property
                    var obj1 = {};
                    Object.defineProperty(obj1, 'x', { value: 42, writable: false });
                    obj1.x = 9; // throws a TypeError

                    // Assignment to a getter-only property
                    var obj2 = { get x() { return 17; } };
                    obj2.x = 5; // throws a TypeError

                    // Assignment to a new property on a non-extensible object
                    var fixed = {};
                    Object.preventExtensions(fixed);
                    fixed.newProp = 'ohai'; // throws a TypeError
            iii) Exception is thrown when trying to delete an undeletable property
                Eg: 'use strict';
                    delete Object.prototype; // throws a TypeError
            iv) Normally if you define the object with same key names then it is allowed and the later value is picked. But strict did not allow this. Though in ES6 it is allowed.
                Eg: 'use strict';
                    var o = { p: 1, p: 2 };
            v)  Strict mode requires function parameter names to be unique. The last value is taken and overrides the previous value. But this is highly undesirable and shouldn't be allowed.
                Eg: function sum(a, a, c) { // !!! syntax error
                        'use strict';
                        return a + a + c; // wrong if this code ran
                    }
            vi) Strict mode forbids octal syntax. Normally octal syntax isn't allowed in ECMAScript2015 but the browsers supported it. So later it was dony by prefixing a zero before the number i.e. 0644(octal) == 420(decimal). Novice developers didn't know the semantic meaning of using a zero before the number and they use it.
                Eg: 'use strict';
                    var sum = 015 + // !!! syntax error
                            197 +
                            142;

                    var sumWithOctal = 0o10 + 8;
                    console.log(sumWithOctal); // 16

                To avoid this '0o' is used before number in strict mode to specify it as an octal number
            vii) Strict mode forbids setting properties on primitive values. Without strict mode they are ignored.
                Eg: (function() {
                    'use strict';

                    false.true = '';         // TypeError
                    (14).sailing = 'home';   // TypeError
                    'with'.you = 'far away'; // TypeError

                    })();
        * Simplifying variable uses:
            i) 'with' is prohibited by strict mode: 'with' is not recommended due to various bugs. Strict mode doesn't allow it.
                Eg: 'use strict';
                    var x = 17;
                    with (obj) { // !!! syntax error
                        // If this weren't strict mode, would this be var x, or
                        // would it instead be obj.x?  It's impossible in general
                        // to say without running the code, so the name can't be
                        // optimized.
                        x;
                    }
            ii) eval invoked in strict mode: the variable defined in eval normally can be used in the global scope. But with strict mode the variable defined inside eval has scope inside eval only.
                Eg: var x = 17;
                    var evalX = eval("'use strict'; var x = 42; x;");
                    console.assert(x === 17);
                    console.assert(evalX === 42);
            
                Eg: function strict1(str) {
                        'use strict';
                        return eval(str); // str will be treated as strict mode code
                    }
                    function strict2(f, str) {
                        'use strict';
                        return f(str); // not eval(...): str is strict if and only
                                        // if it invokes strict mode
                    }
                    function nonstrict(str) {
                        return eval(str); // str is strict if and only 
                                            // if it invokes strict mode
                    }

                    strict1("'Strict mode code!'");
                    strict1("'use strict'; 'Strict mode code!'");
                    strict2(eval, "'Non-strict code.'");
                    strict2(eval, "'use strict'; 'Strict mode code!'");
                    nonstrict("'Non-strict code.'");
                    nonstrict("'use strict'; 'Strict mode code!'");

                    Thus names in strict mode eval code behave identically to names in strict mode code not being evaluated as the result of eval.
            iii) delete is a syntax error in strict mode.
                Eg: 'use strict';
                    var x;
                    delete x; // !!! syntax error
                    eval('var y; delete y;'); // !!! syntax error

        * Making eval and arguments simple:
            strict mode does not allow these 2 names to be used other than keyword
            Eg: 'use strict';
                eval = 17;
                arguments++;
                ++eval;
                var obj = { set p(arguments) { } };
                var eval;
                try { } catch (arguments) { }
                function x(eval) { }
                function arguments() { }
                var y = function eval() { };
                var f = new Function('arguments', "'use strict'; return 17;");
            
            strict mode doesnt tamper with the original values of argument.
            Eg: function f(a) {
                    'use strict';
                    a = 42;
                    return [a, arguments[0]];
                }
                var pair = f(17);
                console.assert(pair[0] === 42);
                console.assert(pair[1] === 17);
            
            strict mode doesnt allow argument.callee anymore
            Eg: 'use strict';
                var f = function() { return arguments.callee; };
                f(); // throws a TypeError

        * Securing javascript: Javascript is a flexible language and needs to perform many runtime checks to secure users information or anything. Nowadays even on browsers we can code javascript. Some strict mode tweaks prevent the use of some runtime checks.
            Eg: 'use strict';
                function fun() { return this; }
                console.assert(fun() === undefined);
                console.assert(fun.call(2) === 2);
                console.assert(fun.apply(null) === null);
                console.assert(fun.call(undefined) === undefined);
                console.assert(fun.bind(true)() === true);

            Second, when a function is called then function.caller is the recent function called and function.arguments is the argument being passed. Both extensions are problematic for "secure" JavaScript because they allow "secured" code to access "privileged" functions and their (potentially unsecured) arguments.
                function restricted() {
                    'use strict';
                    restricted.caller;    // throws a TypeError
                    restricted.arguments; // throws a TypeError
                }
                function privilegedInvoker() {
                    return restricted();
                }
                privilegedInvoker();

            Third, arguments for strict mode functions no longer provide access to the corresponding function call's variables.
                'use strict';
                function fun(a, b) {
                    'use strict';
                    var v = 12;
                    return arguments.caller; // throws a TypeError
                }
                fun(1, 2); // doesn't expose v (or a or b)

11. this keyword: 
        Eg: const test = {
                prop: 42,
                func: function() {
                    return this.prop;
                },
            };

            console.log(test.func());
            // expected output: 42

        * Global context:
            Eg: // In web browsers, the window object is also the global object:
                console.log(this === window); // true

                a = 37;
                console.log(window.a); // 37

                this.b = "MDN";
                console.log(window.b)  // "MDN"
                console.log(b)         // "MDN"

        * Function context:
            i) Simple call:
                In non-strict mode:
                    function f1() {
                        return this;
                    }

                    // In a browser:
                    f1() === window; // true 

                    // In Node:
                    f1() === global; // true

                In strict mode:
                    function f2() {
                        'use strict'; // see strict mode
                        return this;
                    }

                    f2() === undefined; // true

            To set the value of this to a particular value when calling a function, use call(), or apply() as in the following examples.
                a)  // An object can be passed as the first argument to call or apply and this will be bound to it.
                    var obj = {a: 'Custom'};

                    // This property is set on the global object
                    var a = 'Global';

                    function whatsThis() {
                        return this.a;  // The value of this is dependent on how the function is called
                    }

                    whatsThis();          // 'Global'
                    whatsThis.call(obj);  // 'Custom'
                    whatsThis.apply(obj); // 'Custom'

                b)  function add(c, d) {
                        return this.a + this.b + c + d;
                    }

                    var o = {a: 1, b: 3};

                    // The first parameter is the object to use as
                    // 'this', subsequent parameters are passed as 
                    // arguments in the function call
                    add.call(o, 5, 7); // 16

                    // The first parameter is the object to use as
                    // 'this', the second is an array whose
                    // members are used as the arguments in the function call
                    add.apply(o, [10, 20]); // 34

                    Note that in non–strict mode, with call and apply, if the value passed as this is not an object, an attempt will be made to convert it to an object using the internal ToObject operation. So if the value passed is a primitive like 7 or 'foo', it will be converted to an Object using the related constructor, so the primitive number 7 is converted to an object as if by new Number(7) and the string 'foo' to an object as if by new String('foo'), e.g.

                    function bar() {
                    console.log(Object.prototype.toString.call(this));
                    }

                    bar.call(7);     // [object Number]
                    bar.call('foo'); // [object String]

            ii) bind method:
                Eg: function f() {
                        return this.a;
                    }

                    var g = f.bind({a: 'azerty'});
                    console.log(g()); // azerty

                    var h = g.bind({a: 'yoo'}); // bind only works once!
                    console.log(h()); // azerty

                    var o = {a: 37, f: f, g: g, h: h};
                    console.log(o.a, o.f(), o.g(), o.h()); // 37,37, azerty, azerty

            iii) Arrow functions:
                a)  var globalObject = this;
                    var foo = (() => this);
                    console.log(foo() === globalObject); // true

                b)  // Call as a method of an object
                    var obj = {func: foo};
                    console.log(obj.func() === globalObject); // true

                    // Attempt to set this using call
                    console.log(foo.call(obj) === globalObject); // true

                    // Attempt to set this using bind
                    foo = foo.bind(obj);
                    console.log(foo() === globalObject); // true

                c)  // Create obj with a method bar that returns a function that
                    // returns its this. The returned function is created as 
                    // an arrow function, so its this is permanently bound to the
                    // this of its enclosing function. The value of bar can be set
                    // in the call, which in turn sets the value of the 
                    // returned function.
                    var obj = {
                        bar: function() {
                            var x = (() => this);
                            return x;
                        }
                    };

                    // Call bar as a method of obj, setting its this to obj
                    // Assign a reference to the returned function to fn
                    var fn = obj.bar();

                    // Call fn without setting this, would normally default
                    // to the global object or undefined in strict mode
                    console.log(fn() === obj); // true

                    // But caution if you reference the method of obj without calling it
                    var fn2 = obj.bar;
                    // Calling the arrow function's this from inside the bar method()
                    // will now return window, because it follows the this from fn2.
                    console.log(fn2()() == window); // true

            iv) As an object method:
                a)  var o = {
                    prop: 37,
                        f: function() {
                            return this.prop;
                        }
                    };

                b)  var o = {prop: 37};
                    function independent() {
                        return this.prop;
                    }
                    o.f = independent;
                    console.log(o.f()); // 37

                c)  this on an object prototype chain:
                    var o = {f: function() { return this.a + this.b; }};
                    var p = Object.create(o); // this binds automatically when assign to Object prototype
                    p.a = 1;
                    p.b = 4;

                    console.log(p.f()); // 5

                d)  this with a getter and setter:
                    function sum() {
                        return this.a + this.b + this.c;
                    }
                    var o = {
                        a: 1,
                        b: 2,
                        c: 3,
                        get average() {
                            return (this.a + this.b + this.c) / 3;
                        }
                    };
                    Object.defineProperty(o, 'sum', {get: sum, enumerable: true, configurable: true});
                    console.log(o.average, o.sum); // 2, 6
                e)  this used in a constructor:
                    /*
                    * Constructors work like this:
                    *
                    * function MyConstructor(){
                    *   // Actual function body code goes here.  
                    *   // Create properties on |this| as
                    *   // desired by assigning to them.  E.g.,
                    *   this.fum = "nom";
                    *   // et cetera...
                    *
                    *   // If the function has a return statement that
                    *   // returns an object, that object will be the
                    *   // result of the |new| expression.  Otherwise,
                    *   // the result of the expression is the object
                    *   // currently bound to |this|
                    *   // (i.e., the common case most usually seen).
                    * }
                    */

                    function C() {
                        this.a = 37;
                    }

                    var o = new C();
                    console.log(o.a); // 37


                    function C2() {
                        this.a = 37;
                        return {a: 38};
                    }

                    o = new C2();
                    console.log(o.a); // 38

                f) As a DOM event handler:
                    // When called as a listener, turns the related element blue
                    function bluify(e) {
                        // Always true
                        console.log(this === e.currentTarget);
                        // true when currentTarget and target are the same object
                        console.log(this === e.target);
                        this.style.backgroundColor = '#A5D9F3';
                    }

                    // Get a list of every element in the document
                    var elements = document.getElementsByTagName('*');

                    // Add bluify as a click listener so when the
                    // element is clicked on, it turns blue
                    for (var i = 0; i < elements.length; i++) {
                        elements[i].addEventListener('click', bluify, false);
                    }

                g) In inline event handler:
                    <button onclick="alert((function() { return this; })());">
                        Show inner this
                    </button>
                    // Output: button

                    <button onclick="alert(this.tagName.toLowerCase());">
                        Show this
                    </button>
                    //Output: [object Window]

                h) 

12. yield: The yield keyword is used to pause and resume a generator function (function* or legacy generator function).
    Eg: function* foo(index) {
            while (index < 2) {
                yield index++;
            }
        }

        const iterator = foo(0);

        console.log(iterator.next().value);
        // expected output: 0

        console.log(iterator.next().value);
        // expected output: 1

    The yield keyword causes the call to the generator's next() method to return an IteratorResult object with two properties: value and done. The value property is the result of evaluating the yield expression, and done is false, indicating that the generator function has not fully completed.

    Once paused on a yield expression, the generator's code execution remains paused until the generator's next() method is called. Each time the generator's next() method is called, the generator resumes execution, and runs until it reaches one of the following:
        i) A yield, which causes the generator to once again pause and return the generator's new value. The next time next() is called, execution resumes with the statement immediately after the yield.
        ii) throw is used to throw an exception from the generator. This halts execution of the generator entirely, and execution resumes in the caller (as is normally the case when an exception is thrown).
        iii) The end of the generator function is reached. In this case, execution of the generator ends and an IteratorResult is returned to the caller in which the value is undefined and done is true.
        iv) A return statement is reached. In this case, execution of the generator ends and an IteratorResult is returned to the caller in which the value is the value specified by the return statement and done is true.

    Example
        function* countAppleSales () {
            let saleList = [3, 7, 5]
            for (let i = 0; i < saleList.length; i++) {
                yield saleList[i]
            }
        }

        Once a generator function is defined, it can be used by constructing an iterator as shown.

        let appleStore = countAppleSales()  // Generator { }
        console.log(appleStore.next())      // { value: 3, done: false }
        console.log(appleStore.next())      // { value: 7, done: false }
        console.log(appleStore.next())      // { value: 5, done: false }
        console.log(appleStore.next())      // { value: undefined, done: true }

13. Functions:
    i) Can be assigned to a variable
    ii) Can be passed as an argument in a function
    iii) Can be returned from a function as well
    
    Eg 1)   console.log(square(5));
            /* ... */
            function square(n) { return n * n; }

            Output: 25

    Eg 2)   console.log(square(5));
            var square = function(n) { 
            return n * n; 
            }

            Output: TypeError: square is not a function

            Reason: In Javascript, if you define a function as a variable then the variable is hoisted but cant be accessed until the Javascript execution encounters its definition.

    Eg 3)   var simpleLibrary = function() {
                var simpleLibrary = {
                        a,
                        b,
                        add: function(a, b) {
                            return a + b;
                        },
                        subtract: function(a, b) {
                            return a - b;   
                        }
                }
                return simpleLibrary;
            }();

            It is function variable that has variables and functions encapsulated which do not disturb the global scope. This is used by jQuery, Lodash etc.

    If a primitive value like a variable is passed as a parameter to the function and that function performs something with the parameter then only the value of parameter is changed and not the variable. But if a non-primitive value like object is sent as a parameter to the function and some changes are made in the object then those changes are reflected outside the function as well.
        Eg -function myFunc(theObject) {
                theObject.make = 'Toyota';
            }

            var mycar = {make: 'Honda', model: 'Accord', year: 1998};
            var x, y;

            x = mycar.make; // x gets the value "Honda"

            myFunc(mycar);
            y = mycar.make; // y gets the value "Toyota"
                            // (the make property was changed by the function)

    Function expressions:
        When a function is defined in an expression. Like assigned to a variable or made by function constructor
        Eg -    const getRectArea = function(width, height) {
                    return width * height;
                }

                console.log(getRectArea(3,4));
                //output: 12

        The difference between function declaration and function expression is that the later can be used without a function name also known as Anonymous Functions. Also they can be used as IIFE(Immediately invoked function expressions)

        Function expression hoisting: Unlike function declarations, function expressions are not hoisted unless they are defined before
            Eg: console.log(notHoisted) // undefined 
                //even though the variable name is hoisted, the definition isn't. so it's undefined.
                notHoisted(); // TypeError: notHoisted is not a function

                var notHoisted = function() {
                console.log('bar');
                };

        Named function expression: If a name is given to the function in function expression then it is named function expression. This name is only local to the function body(scope). Giving the name to the function also makes it easy to identify the function in debugging stack trace.
            Eg: var math = {
                    'factit': function factorial(n) {
                        console.log(n)
                        if (n <= 1) {
                        return 1;
                        }
                        return n * factorial(n - 1);
                    }
                };

                math.factit(3) //3;2;1;

            In objects the name of the key doesnt change even if the object name is changed or assigned to another object.
            Eg: var foo = function() {}
                foo.name // "foo"

                var foo2 = foo
                foo2.name // "foo"

                var bar = function baz() {}
                bar.name // "baz"

                console.log(foo === foo2); // true
                console.log(typeof baz); // undefined
                console.log(bar === baz); // false (errors because baz == undefined)

            Eg: Function expressions are convenient when passed as an argument to some other functions. Like in the following function f is passed as an argument. It executes everytime it is encountered in the loop.
                function map(f, a) {
                    let result = []; // Create a new Array
                    let i; // Declare variable
                    for (i = 0; i != a.length; i++)
                        result[i] = f(a[i]);
                    return result;
                }
                const f = function(x) {
                    return x * x * x; 
                }
                let numbers = [0, 1, 2, 5, 10];
                let cube = map(f,numbers);
                console.log(cube);

                //Output: [0, 1, 8, 125, 1000]
    
    IIFE(Immediately invoked function expression):
        These are the Self invoking Anonymous function expression which are interpreted and implemented when they are defined.
        Eg: (function () {
                statements
            })();

        There are 2 parts to the above example:
        i) According to the Lexical Scoping the outer paranthesis () inside which the IIFE is defined cannot access the parameters of the IIFE which disturbs the global scope.
        ii) The IIFE which is invoked immediately and interpreted by the Javascript engine.

        Eg: (function () {
                var aName = "Barry";
            })();
            // Variable aName is not accessible from the outside scope
            aName // throws "Uncaught ReferenceError: aName is not defined"

        Assigning IIFE to a variable stores the return value of the function and not the function itself
        Eg: var result = (function () {
                var name = "Barry"; 
                return name; 
            })(); 
            // Immediately creates the output: 
            result; // "Barry"

    In Javascript, function can be assigned on condition basis as well.
    Eg: var myFunc;
        if (num === 0) {
            myFunc = function(theObject) {
                theObject.make = 'Toyota';
            }
        }

    
    eval(): The eval function evaluates Javascript code represented as a string.
        Eg: console.log(eval('2 + 2'));
            // expected output: 4

            console.log(eval(new String('2 + 2')));
            // expected output: 2 + 2

            console.log(eval('2 + 2') === eval('4'));
            // expected output: true

            console.log(eval('2 + 2') === eval(new String('2 + 2')));
            // expected output: false
        Executing Javascript from a string is an enormous security risk. Third party can easily see the scope of eval() and attack in many possible ways.

        Bad code with eval():
            function looseJsonParse(obj){
                return eval("(" + obj + ")");
            }
            console.log(looseJsonParse(
            "{a:(4-1), b:function(){}, c:new Date()}"
            ))

        Better code without eval():
            function looseJsonParse(obj){
                return Function('"use strict";return (' + obj + ')')();
            }
            console.log(looseJsonParse(
            "{a:(4-1), b:function(){}, c:new Date()}"
            ))

    Function constructor: Function constructor creates a new Function object. It executes in a global scope.
        Eg: const sum = new Function('a', 'b', 'return a + b');
            console.log(sum(2, 6));
            //output: 8

    Calling Functions: There are many ways to call a function.
        Eg: console.log(square(5));
            /* ... */
            function square(n) { return n * n }
        
        Functions must be in scope to be called. Function hoisting only works with function declarations and not function expressions.
        Eg: console.log(square)    // square is hoisted with an initial value undefined.
            console.log(square(5)) // Uncaught TypeError: square is not a function
            const square = function(n) { 
            return n * n; 
            }

        You can pass the whole function as an argument. A function can also call itself known as recursion.
        Eg: function factorial(n) {
            if ((n === 0) || (n === 1))
                return 1;
            else
                return (n * factorial(n - 1));
            }

    Function scope: Function can access all the variables and functions defined in that scope.
        Eg: // The following variables are defined in the global scope
            var num1 = 20,
                num2 = 3,
                name = 'Chamahk';

            // This function is defined in the global scope
            function multiply() {
            return num1 * num2;
            }

            multiply(); // Returns 60

            // A nested function example
            function getScore() {
            var num1 = 2,
                num2 = 3;
            
            function add() {
                return name + ' scored ' + (num1 + num2);
            }
            
            return add();
            }

            getScore(); // Returns "Chamahk scored 5"

    Scope and function stack:
        i) Recursion: When a function call itself. They are 3 ways to do it:
            * function name
            * arguments.callee
            * An in-scope variable that refers the function
            Eg: var foo = function bar() {
                        // statements go here
                    }
                Within the function body, the following are all equivalent:
                    bar()
                    arguments.callee()
                    foo()

            Eg: var x = 0;
                while (x < 10) { // "x < 10" is the loop condition
                // do stuff
                x++;
                }
            
                ...can be converted into a recursive function declaration, followed by a call to that function:

                function loop(x) {
                if (x >= 10) // "x >= 10" is the exit condition (equivalent to "!(x < 10)")
                    return;
                // do stuff
                loop(x + 1); // the recursive call
                }
                loop(0);

            Some algorithms cannot be simple iterative loops.
                Eg: Getting all the nodes of a tree via recursion.
                    function walkTree(node) {
                        if (node == null) // 
                            return;
                        // do something with node
                        for (var i = 0; i < node.childNodes.length; i++) {
                            walkTree(node.childNodes[i]);
                        }
                    }

            Compared to the function loop, each recursive call itself makes many recursive calls here.
            It is possible to convert any recursive function into a non-recursive one. But it requires a logic to exit but it uses a stack. Recursive function in itself is a stack.
                Eg: function foo(i) {
                        if (i < 0)
                            return;
                        console.log('begin: ' + i);
                        foo(i - 1);
                        console.log('end: ' + i);
                    }
                    foo(3);

                    // Output:
                    // begin: 3
                    // begin: 2
                    // begin: 1
                    // begin: 0
                    // end: 0
                    // end: 1
                    // end: 2
                    // end: 3

        ii) Nested functions and closures:
            * The inner function can only be accessed only from statements inside the outer function.
            * The inner function forms a closure (A closure is an expression that have free variables with an environment that binds those variables).the inner function can use the arguments and variables of the outer function, while the outer function cannot use the arguments and variables of the inner function.
                Eg: function addSquares(a, b) {
                        function square(x) {
                            return x * x;
                        }
                        return square(a) + square(b);
                    }
                    a = addSquares(2, 3); // returns 13
                    b = addSquares(3, 4); // returns 25
                    c = addSquares(4, 5); // returns 41

                Eg: function outside(x) {
                        function inside(y) {
                            return x + y;
                        }
                        return inside;
                    }
                    fn_inside = outside(3); // Think of it like: give me a function that adds 3 to whatever you give
                                            // it
                    result = fn_inside(5); // returns 8

                    result1 = outside(3)(5); // returns 8

        iii) Preservation of variables: Notice how in the above example x is preserved when inside is returned. A closure must preserve the arguments and variables in all scopes it references.
        
        iv) Multiply nested functions:
            Functions can be multiply-nested.  For example:
                * A function (A) contains a function (B), which itself contains a function (C).
                * Both functions B and C form closures here. So, B can access A, and C can access B.
                * In addition, since C can access B which can access A, C can also access A.

            Thus the closures can contain many scopes. They recursively contain the scope of the function containing it. This is called Scope chaining.
            Eg: function A(x) {
                    function B(y) {
                        function C(z) {
                        console.log(x + y + z);
                        }
                        C(3);
                    }
                    B(2);
                }
                A(1); // 6 (1 + 2 + 3)
                In this example, C accesses B's y and A's x. This can be done because:
                    - B forms a closure including A (i.e. B can access A's arguments and variables).
                    - C forms a closure including B.
                    - Because B's closure includes A, C's closure includes A, C can access both B and A's arguments and variables. In other words, C chains the scopes of B and A, in that order.

        v)  Name conflicts:
            When 2 arguments or variables have the same name then conflict occurs. When this happens the innermost scope takes the highest precedence and the outermost scope takes the lowest precedence.
            Eg: function outside() {
                    var x = 5;
                    function inside(x) {
                        return x * 2;
                    }
                    return inside;
                }

                outside()(10); // returns 20 instead of 10. The scope chain here is {inside, outside, global object}.

    Closures: Javascript allows for the nested functions in which the inner function can access all the variables and functions of the outer function.

        However the outer function cannot access the variables and functions of the inner function. This provides a kind of encapsulation for the variables inside the inner function. Also since the inner function has access to the outer functions variable the scope of those variables live longer than the outer functions if the life of inner function goes beyond the life of outer function.
        Eg: var pet = function(name) {          // The outer function defines a variable called "name"
                var getName = function() {
                    return name;                // The inner function has access to the "name" variable of the outer function
                }
                return getName;                 // Return the inner function, thereby exposing it to outer scopes
            }
            myPet = pet('Vivie');
            
            myPet();                            // Returns "Vivie"

        Eg: var createPet = function(name) {
                var sex;
                
                return {
                    setName: function(newName) {
                    name = newName;
                    },
                    
                    getName: function() {
                    return name;
                    },
                    
                    getSex: function() {
                    return sex;
                    },
                    
                    setSex: function(newSex) {
                    if(typeof newSex === 'string' && (newSex.toLowerCase() === 'male' || 
                        newSex.toLowerCase() === 'female')) {
                        sex = newSex;
                    }
                    }
                }
            }

            var pet = createPet('Vivie');
            pet.getName();                  // Vivie

            pet.setName('Oliver');
            pet.setSex('male');
            pet.getSex();                   // male
            pet.getName();                  // Oliver

        Eg: var getCode = (function() {
                var apiCode = '0]Eal(eh&2';    // A code we do not want outsiders to be able to modify...
                
                return function() {
                    return apiCode;
                };
            })();

            getCode();    // Returns the apiCode

            The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.

        Caution: If an enclosed function defines a variable with the same name as a variable in the outer scope, then there is no way to refer to the variable in the outer scope again.  (The inner scope variable "overrides" the outer one, until the program exits the inner scope.)
        Eg: var createPet = function(name) {  // The outer function defines a variable called "name".
                return {
                    setName: function(name) {    // The enclosed function also defines a variable called "name".
                    name = name;               // How do we access the "name" defined by the outer function?
                    }
                }
            }
    

    Using the arguments object: arguments of a function are maintained in an array like object. Within a function, you can address the arguments passed to it as arguments[i], where i is the ordinal number of the argument, starting at 0. So, the first argument passed to a function would be arguments[0]. The total number of arguments is indicated by arguments.length.
        Eg: Concatenation of strings
            function myConcat(separator) {
                var result = ''; // initialize list
                var i;
                // iterate through arguments
                for (i = 1; i < arguments.length; i++) {
                    result += arguments[i] + separator;
                }
                return result;
            }

            // returns "red, orange, blue, "
            myConcat(', ', 'red', 'orange', 'blue');

            // returns "elephant; giraffe; lion; cheetah; "
            myConcat('; ', 'elephant', 'giraffe', 'lion', 'cheetah');

            // returns "sage. basil. oregano. pepper. parsley. "
            myConcat('. ', 'sage', 'basil', 'oregano', 'pepper', 'parsley');

    Function parameters: 
        In ECMAScript 2015: Default and rest
            i) Default parameters: Default value is given to an argument. Default value is undefined but separate value can be given as well.
                Eg: Without Default -
                    function multiply(a, b) {
                        b = typeof b !== 'undefined' ?  b : 1; //If this line is not there then output will be NaN

                        return a * b;
                    }

                    multiply(5); // 5

                    With Default -
                    function multiply(a, b = 1) {
                        return a * b;
                    }

                    multiply(5); // 5
            ii) Rest parameters: Indefinite numbers of arguments can be provided in this.
                Eg: the function multiply uses rest parameters to collect arguments from the second one to the end. The function then multiplies these by the first argument . 

                    function multiply(multiplier, ...theArgs) {
                        return theArgs.map(x => multiplier * x);
                    }

                    var arr = multiply(2, 1, 2, 3);
                    console.log(arr); // [2, 4, 6]

    Arrow Functions: They are syntactically compact function expressions, although without its own bindings to this, arguments, new.target or super
        Basic Syntax:   (param1, param2, …, paramN) => { statements } 
                        (param1, param2, …, paramN) => expression
                        // equivalent to: => { return expression; }

                        // Parentheses are optional when there's only one parameter name:
                        (singleParam) => { statements }
                        singleParam => { statements }

                        // The parameter list for a function with no parameters should be written with a pair of parentheses.
                        () => { statements }

        Advanced Syntax:    // Parenthesize the body of a function to return an object literal expression:
                            params => ({foo: bar})

                            // Rest parameters and default parameters are supported
                            (param1, param2, ...rest) => { statements }
                            (param1 = defaultValue1, param2, …, paramN = defaultValueN) => { 
                            statements }

                            // Destructuring within the parameter list is also supported
                            var f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;
                            f(); // 6

        Description: Two factors influenced the need for arrow functions: shorter functions and behaviour of this keywords.
            i) Shorter functions:
                Eg: var elements = [
                    'Hydrogen',
                    'Helium',
                    'Lithium',
                    'Beryllium'
                ];

                // This statement returns the array: [8, 6, 7, 9]
                elements.map(function(element) {
                    return element.length;
                });

                // The regular function above can be written as the arrow function below
                elements.map((element) => {
                    return element.length;
                }); // [8, 6, 7, 9]

                // When there is only one parameter, we can remove the surrounding parentheses
                elements.map(element => {
                    return element.length;
                }); // [8, 6, 7, 9]

                // When the only statement in an arrow function is `return`, we can remove `return` and remove
                // the surrounding curly brackets
                elements.map(element => element.length); // [8, 6, 7, 9]

                // In this case, because we only need the length property, we can use destructuring parameter:
                // Notice that the `length` corresponds to the property we want to get whereas the
                // obviously non-special `lengthFooBArX` is just the name of a variable which can be changed
                // to any valid variable name you want
                elements.map(({ length: lengthFooBArX }) => lengthFooBArX); // [8, 6, 7, 9]

                // This destructuring parameter assignment can also be written as seen below. However, note that in
                // this example we are not assigning `length` value to the made up property. Instead, the literal name
                // itself of the variable `length` is used as the property we want to retrieve from the object.
                elements.map(({ length }) => length); // [8, 6, 7, 9] 

            ii) Before arrow functions every new function defined its this in a way they were called.
                Eg: function Person() {
                        // The Person() constructor defines `this` as an instance of itself.
                        this.age = 0;

                        setInterval(function growUp() {
                            // In non-strict mode, the growUp() function defines `this`
                            // as the global object (because it's where growUp() is executed.), 
                            // which is different from the `this`
                            // defined by the Person() constructor.
                            this.age++;
                        }, 1000);
                    }
                    var p = new Person();

                In ECMAScript 3/5, the this issue was fixable by assigning the value in this to a variable that could be closed over.

                    function Person() {
                        var that = this;
                        that.age = 0;

                        setInterval(function growUp() {
                            // The callback refers to the `that` variable of which
                            // the value is the expected object.
                            that.age++;
                        }, 1000);
                    }

                Arrow functions does not have its own this. So it uses lexical scoping for this. So while searching for this arrow function sets this from its enclosing scope.
                    Eg: function Person(){
                            this.age = 0;

                            setInterval(() => {
                                this.age++; // |this| properly refers to the Person object
                            }, 1000);
                        }
                        var p = new Person();


                Relation with Strict mode: since arrow functions do not have their own this then strict mode rules do not apply.
                    Eg: var f = () => { 'use strict'; return this; };
                        f() === window; // or the global object

                Invoked through call or apply: since arrow functions do not have their own this so this argument passed through call or apply is ignored.
                    Eg: var adder = {
                            base: 1,
                            add: function(a) {
                                var f = v => v + this.base;
                                return f(a);
                            },

                            addThruCall: function(a) {
                                var f = v => v + this.base;
                                var b = {
                                base: 2
                                };

                                return f.call(b, a);
                            }
                        };

                        console.log(adder.add(1));         // This would log 2
                        console.log(adder.addThruCall(1)); // This would log 2 still

                No binding of arguments: since arrow functions have no this of their own
                    var arguments = [1, 2, 3];
                    var arr = () => arguments[0];

                    arr(); // 1

                    function foo(n) {
                        var f = () => arguments[0] + n; // foo's implicit arguments binding. arguments[0] is n
                        return f();
                    }

                    foo(3); // 6

                    In most cases, using rest parameters is a good alternative to using an arguments object.
                        function foo(n) { 
                            var f = (...args) => args[0] + n;
                            return f(10); 
                        }
                        foo(1); // 11

            iii) Arrow functions used a methods:
                    'use strict';
                    var obj = { // does not create a new scope
                        i: 10,
                        b: () => console.log(this.i, this),
                        c: function() {
                            console.log(this.i, this);
                        }
                    }
                    obj.b(); // prints undefined, Window {...} (or the global object)
                    obj.c(); // prints 10, Object {...}

                Arrow functions do not have their own this. Another example involving Object.defineProperty():

                    'use strict';

                    var obj = {
                        a: 10
                    };

                    Object.defineProperty(obj, 'b', {
                        get: () => {
                            console.log(this.a, typeof this.a, this); // undefined 'undefined' Window {...} (or the global object)
                            return this.a + 10; // represents global object 'Window', therefore 'this.a' returns 'undefined'
                        }
                    });

            iv) Use of the new operator: Arrow functions cannot be used as constructors and will throw an error when used with new.
                    var Foo = () => {};
                    var foo = new Foo(); // TypeError: Foo is not a constructor

            v)  Use of prototype property: Arrow functions do not have a prototype property.
                    var Foo = () => {};
                    console.log(Foo.prototype); // undefined

            vi) Use of the yield keyword: The yield keyword may not be used in an arrow function's body (except when permitted within functions further nested within it). As a consequence, arrow functions cannot be used as generators.

            vii)Returning object literals: Keep in mind that returning object literals using the concise body syntax params => {object:literal} will not work as expected.
                    Eg: var func = () => { foo: 1 };
                        // Calling func() returns undefined!

                        var func = () => { foo: function() {} };
                        // SyntaxError: function statement requires a name

                    This is because the code inside braces ({}) is parsed as a sequence of statements (i.e. foo is treated like a label, not a key in an object literal). You must wrap the object literal in parentheses:

                        var func = () => ({ foo: 1 });

            viii) Line breaks: An arrow function cannot contain a line break between its parameters and its arrow.

                    var func = (a, b, c)
                        => 1;
                    // SyntaxError: expected expression, got '=>'

                    However, the following are allowed:
                        var func = (a, b, c) =>
                          1;
                        
                        var func = (a, b, c) => (
                            1
                        );

                        var func = (a, b, c) => {
                            return 1
                        };

                        var func = (
                            a,
                            b,
                            c
                        ) => 1;
                        
                        // no SyntaxError thrown

            ix) Parsing order: Although the arrow in an arrow function is not an operator, arrow functions have special parsing rules that interact differently with operator precedence compared to regular functions.

                    let callback;

                    callback = callback || function() {}; // ok

                    callback = callback || () => {};
                    // SyntaxError: invalid arrow-function arguments

                    callback = callback || (() => {});    // ok

            x) Examples:
                // An empty arrow function returns undefined
                let empty = () => {};

                (() => 'foobar')(); 
                // Returns "foobar"
                // (this is an Immediately Invoked Function Expression)

                var simple = a => a > 15 ? 15 : a; 
                simple(16); // 15
                simple(10); // 10

                let max = (a, b) => a > b ? a : b;

                // Easy array filtering, mapping, ...

                var arr = [5, 6, 13, 0, 1, 18, 23];

                var sum = arr.reduce((a, b) => a + b);
                // 66

                var even = arr.filter(v => v % 2 == 0); 
                // [6, 0, 18]

                var double = arr.map(v => v * 2);
                // [10, 12, 26, 0, 2, 36, 46]

                // More concise promise chains
                promise.then(a => {
                    // ...
                }).then(b => {
                    // ...
                });

                // Parameterless arrow functions that are visually easier to parse
                setTimeout( () => {
                    console.log('I happen sooner');
                    setTimeout( () => {
                        // deeper code
                        console.log('I happen later');
                    }, 1);
                }, 1);
                    
    Predefined Functions: JavaScript has several top-level, built-in functions:
        i) eval(): The eval() method evaluates JavaScript code represented as a string.

        ii) isFinite(): The global isFinite() function determines whether the passed value is a finite number. If needed, the parameter is first converted to a number.

        iii) isNaN(): The isNaN() function determines whether a value is NaN or not. Note: coercion inside the isNaN function has interesting rules; you may alternatively want to use Number.isNaN(), as defined in ECMAScript 2015, or you can use typeof to determine if the value is Not-A-Number.

        iv) parseFloat(): The parseFloat() function parses a string argument and returns a floating point number.

        v) parseInt(): The parseInt() function parses a string argument and returns an integer of the specified radix (the base in mathematical numeral systems).

        vi) decodeURI(): The decodeURI() function decodes a Uniform Resource Identifier (URI) previously created by encodeURI or by a similar routine.

        vii) decodeURIComponent(): The decodeURIComponent() method decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent or by a similar routine.

        viii) encodeURI(): The encodeURI() method encodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two "surrogate" characters).

        ix) encodeURIComponent(): The encodeURIComponent() method encodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two "surrogate" characters).

14. Working with objects: Javascript is an object based paradigm. Object has properties. Properties has key value pairs. Values can be function as well. Property accessors are used to get value of a key i.e by dot notation, bracket notation etc.

    Unassigned properties of an object are undefined (and not null).
        myCar.color; // undefined
    
    Objects are sometimes called Associative arrays because each property has a key which is a string value and can be accessed as following:
        myCar['make'] = 'Ford';
        myCar['model'] = 'Mustang';
        myCar['year'] = 1969;

    If the key has a space or hyphen then it can only be accessed using square bracket notations.
        // four variables are created and assigned in a single go, 
        // separated by commas
        var myObj = new Object(),
            str = 'myString',
            rand = Math.random(),
            obj = new Object();

        myObj.type              = 'Dot syntax';
        myObj['date created']   = 'String with space';
        myObj[str]              = 'String value';
        myObj[rand]             = 'Random Number';
        myObj[obj]              = 'Object';
        myObj['']               = 'Even an empty string';

        console.log(myObj);

        Output: {
            type: "Dot syntax"
            date created: "String with space"
            myString: "String value"
            0.8751481848891265: "Random Number"
            [object Object]: "Object"
            "": "Even an empty string"
        }

    We can also use the for...in to iterate over the object.
    Eg: function showProps(obj, objName) {
            var result = ``;
            for (var i in obj) {
                // obj.hasOwnProperty() is used to filter out properties from the object's prototype chain
                if (obj.hasOwnProperty(i)) {
                result += `${objName}.${i} = ${obj[i]}\n`;
                }
            }
            return result;
        }
        showProps(myCar, "myCar");
        //Output:
            myCar.make = Ford
            myCar.model = Mustang
            myCar.year = 1969

    Enumeration of the objects: There are 3 ways to traverse through the object and get its keys:
        i) for...in
        ii) Object.keys(o)
        iii) Object.getOwnPropertyNames(o)

        To list all the properties of an object following code can be written:
            Eg: let z = { b:1, c:3, d:4, e:5, f:6 };
                function listAllProperties(o) {
                    var objectToInspect;     
                    var result = [];
                    
                    for(objectToInspect = o; objectToInspect !== null; 
                        objectToInspect = Object.getPrototypeOf(objectToInspect)) {  
                        result = result.concat(
                            Object.getOwnPropertyNames(objectToInspect)
                        );  
                    }
                    
                    return result; 
                }

                //Output:
                    ["b", "c", "d", "e", "f", "constructor", "__defineGetter__", "__defineSetter__", "hasOwnProperty", "__lookupGetter__", "__lookupSetter__", "isPrototypeOf", "propertyIsEnumerable", "toString", "valueOf", "__proto__", "toLocaleString"]

    Creating new objects:
        i) Using object initializer:
            Eg: var obj =   { 
                                property_1:   value_1,   // property_# may be an identifier...
                                2:            value_2,   // or a number...
                                // ...,
                                'property n': value_n    // or a string
                            };
        ii) Using a constructor function:
            Eg: function Car(make, model, year) {
                    this.make = make;
                    this.model = model;
                    this.year = year;
                }
                var mycar = new Car('Eagle', 'Talon TSi', 1993);
        iii) Using Object.create method:
            Eg: // Animal properties and method encapsulation
                var Animal = {
                    type: 'Invertebrates', // Default value of properties
                    displayType: function() {  // Method which will display type of Animal
                        console.log(this.type);
                    }
                };

                // Create new animal type called animal1 
                var animal1 = Object.create(Animal);
                animal1.displayType(); // Output:Invertebrates

                // Create new animal type called Fishes
                var fish = Object.create(Animal);
                fish.type = 'Fishes';
                fish.displayType(); // Output:Fishes

    Inheritance: Every object in javascript inherits from atleast one other object. The object being inherited from is known as prototype. And the inherited properties can be found in prototype object.
        Each object in javascript holds a private property which holds a link to another object. The prototype object has a prototype property of its own and so on until an object reaches null as its prototype. Then further null has no prototype and the prototype chain ends here.

        Inheritance with prototype chain: When trying to access a property from an object, the property wont be only searched on the object but also in its prototype chain until either the property is found or the prototype chain reaches to null.

            Object.getPrototypeOf() & Object.setPrototypeOf() have an alternative i.e. __proto__ which is recognised by many browsers. If there is an object obj then using obj.[[Prototype]] we can designate the prototype of obj.

            Example:Inheriting properties:
                    // Let's create an object o from function f with its own properties a and b:
                    let f = function () {
                        this.a = 1;
                        this.b = 2;
                    }
                    let o = new f(); // {a: 1, b: 2}

                    // add properties in f function's prototype
                    f.prototype.b = 3;
                    f.prototype.c = 4;

                    // do not set the prototype f.prototype = {b:3,c:4}; this will break the prototype chain
                    // o.[[Prototype]] has properties b and c.
                    // o.[[Prototype]].[[Prototype]] is Object.prototype.
                    // Finally, o.[[Prototype]].[[Prototype]].[[Prototype]] is null.
                    // This is the end of the prototype chain, as null,
                    // by definition, has no [[Prototype]].
                    // Thus, the full prototype chain looks like:
                    // {a: 1, b: 2} ---> {b: 3, c: 4} ---> Object.prototype ---> null

                    console.log(o.a); // 1
                    // Is there an 'a' own property on o? Yes, and its value is 1.

                    console.log(o.b); // 2
                    // Is there a 'b' own property on o? Yes, and its value is 2.
                    // The prototype also has a 'b' property, but it's not visited. 
                    // This is called Property Shadowing

                    console.log(o.c); // 4
                    // Is there a 'c' own property on o? No, check its prototype.
                    // Is there a 'c' own property on o.[[Prototype]]? Yes, its value is 4.

                    console.log(o.d); // undefined
                    // Is there a 'd' own property on o? No, check its prototype.
                    // Is there a 'd' own property on o.[[Prototype]]? No, check its prototype.
                    // o.[[Prototype]].[[Prototype]] is Object.prototype and there is no 'd' property by default, check its prototype.
                    // o.[[Prototype]].[[Prototype]].[[Prototype]] is null, stop searching,
                    // no property found, return undefined.
            Example: Inheriting methods:
                    var o = {
                            a: 2,
                            m: function() {
                                return this.a + 1;
                            }
                        };
                    console.log(o.m()); // 3
                    // When calling o.m in this case, 'this' refers to o

                    var p = Object.create(o);
                    // p is an object that inherits from o

                    p.a = 4; // creates a property 'a' on p
                    console.log(p.m()); // 5
                    // when p.m is called, 'this' refers to p.
                    // So when p inherits the function m of o, 
                    // 'this.a' means p.a, the property 'a' of p
        
        Using Prototypes in javascript: 
            Example 1:  function doSomething(){}
                        console.log( doSomething.prototype );
                        // It does not matter how you declare the function, a
                        //  function in JavaScript will always have a default
                        //  prototype property.
                        var doSomething = function(){}; 
                        console.log( doSomething.prototype );

                    As seen above, doSomething() has a default prototype property, as demonstrated by the console. After running this code, the console should have displayed an object that looks similar to this.
            
                        {
                            constructor: ƒ doSomething(),
                            __proto__: {
                                constructor: ƒ Object(),
                                hasOwnProperty: ƒ hasOwnProperty(),
                                isPrototypeOf: ƒ isPrototypeOf(),
                                propertyIsEnumerable: ƒ propertyIsEnumerable(),
                                toLocaleString: ƒ toLocaleString(),
                                toString: ƒ toString(),
                                valueOf: ƒ valueOf()
                            }
                        }

                    We can add properties to the prototype of doSomething(), as shown below.

                        function doSomething(){}
                        doSomething.prototype.foo = "bar";
                        console.log( doSomething.prototype );
            
                    This results in:

                        {
                            foo: "bar",
                            constructor: ƒ doSomething(),
                            __proto__: {
                                constructor: ƒ Object(),
                                hasOwnProperty: ƒ hasOwnProperty(),
                                isPrototypeOf: ƒ isPrototypeOf(),
                                propertyIsEnumerable: ƒ propertyIsEnumerable(),
                                toLocaleString: ƒ toLocaleString(),
                                toString: ƒ toString(),
                                valueOf: ƒ valueOf()
                            }
                        }

            Example 2:  function doSomething(){}
                        doSomething.prototype.foo = "bar";
                        var doSomeInstancing = new doSomething();
                        doSomeInstancing.prop = "some value";
                        console.log("doSomeInstancing.prop:      " + doSomeInstancing.prop);
                        console.log("doSomeInstancing.foo:       " + doSomeInstancing.foo);
                        console.log("doSomething.prop:           " + doSomething.prop);
                        console.log("doSomething.foo:            " + doSomething.foo);
                        console.log("doSomething.prototype.prop: " + doSomething.prototype.prop);
                        console.log("doSomething.prototype.foo:  " + doSomething.prototype.foo);

                        This results in:

                        doSomeInstancing.prop:      some value
                        doSomeInstancing.foo:       bar
                        doSomething.prop:           undefined
                        doSomething.foo:            undefined
                        doSomething.prototype.prop: undefined
                        doSomething.prototype.foo:  bar

        Different ways to create objects and the resulting prototype chain: 
            i)  Objects created with syntax constructs
                var o = {a: 1};

                // The newly created object o has Object.prototype as its [[Prototype]]
                // o has no own property named 'hasOwnProperty'
                // hasOwnProperty is an own property of Object.prototype. 
                // So o inherits hasOwnProperty from Object.prototype
                // Object.prototype has null as its prototype.
                // o ---> Object.prototype ---> null

                var b = ['yo', 'whadup', '?'];

                // Arrays inherit from Array.prototype 
                // (which has methods indexOf, forEach, etc.)
                // The prototype chain looks like:
                // b ---> Array.prototype ---> Object.prototype ---> null

                function f() {
                    return 2;
                }

                // Functions inherit from Function.prototype 
                // (which has methods call, bind, etc.)
                // f ---> Function.prototype ---> Object.prototype ---> null

            ii) With a constructor: A "constructor" in JavaScript is "just" a function that happens to be called with the new operator.

                function Graph() {
                    this.vertices = [];
                    this.edges = [];
                }

                Graph.prototype = {
                    addVertex: function(v) {
                        this.vertices.push(v);
                    }
                };

                var g = new Graph();
                // g is an object with own properties 'vertices' and 'edges'.
                // g.[[Prototype]] is the value of Graph.prototype when new Graph() is executed.

            iii) With Object.create:

                var a = {a: 1}; 
                // a ---> Object.prototype ---> null

                var b = Object.create(a);
                // b ---> a ---> Object.prototype ---> null
                console.log(b.a); // 1 (inherited)

                var c = Object.create(b);
                // c ---> b ---> a ---> Object.prototype ---> null

                var d = Object.create(null);
                // d ---> null
                console.log(d.hasOwnProperty); 
                // undefined, because d doesn't inherit from Object.prototype

            iv) delete Operator with Object.create and new operator: Using Object.create of another object demonstrates prototypical inheritance with the delete operation:
                    var a = {a: 1};

                    var b = Object.create(a); 

                    console.log(a.a); // print 1 
                    console.log(b.a); // print 1
                    b.a=5;
                    console.log(a.a); // print 1
                    console.log(b.a); // print 5
                    delete b.a;
                    console.log(a.a); // print 1
                    console.log(b.a); // print 1(b.a value 5 is deleted but it showing value from its prototype chain)
                    delete a.a;
                    console.log(a.a); // print undefined
                    console.log(b.a); // print undefined

                    The new operator has a shorter chain in this example:
                    function Graph() {
                        this.vertices = [4,4];
                    }

                    var g = new Graph();
                    console.log(g.vertices); // print [4,4]
                    g.vertices = 25;
                    console.log(g.vertices); // print 25
                    delete g.vertices;
                    console.log(g.vertices); // print undefined

            v)  With the class keyword:
                    'use strict';
                    class Polygon {
                        constructor(height, width) {
                            this.height = height;
                            this.width = width;
                        }
                    }

                    class Square extends Polygon {
                        constructor(sideLength) {
                            super(sideLength, sideLength);
                        }
                        get area() {
                            return this.height * this.width;
                        }
                        set sideLength(newLength) {
                            this.height = newLength;
                            this.width = newLength;
                        }
                    }

                    var square = new Square(2);

        Performance: To find the key the iterator iterates over all the proto inside object. So time is taken there.
            Eg: console.log(g.hasOwnProperty('vertices'));
                // true

                console.log(g.hasOwnProperty('nope'));
                // false

                console.log(g.hasOwnProperty('addVertex'));
                // false

                console.log(g.__proto__.hasOwnProperty('addVertex'));
                // true

            hasOwnProperty is the only thing in JavaScript which deals with properties and does not traverse the prototype chain.

            Note: It is not enough to check whether a property is undefined. The property might very well exist, but its value just happens to be set to undefined.

        Bad practice: Extension of native prototypes
                One misfeature that is often used is to extend Object.prototype or one of the other built-in prototypes.
                This technique is called monkey patching and breaks encapsulation. While used by popular frameworks such as Prototype.js, there is still no good reason for cluttering built-in types with additional non-standard functionality.
                The only good reason for extending a built-in prototype is to backport the features of newer JavaScript engines, like Array.forEach.

        Examples:
            i)  New intitialization:
                function foo(){}
                foo.prototype = {
                    foo_prop: "foo val"
                };
                function bar(){}
                var proto = new foo;
                proto.bar_prop = "bar val";
                bar.prototype = proto;
                var inst = new bar;
                console.log(inst.foo_prop);
                console.log(inst.bar_prop);

                //Output:
                foo val
                bar val

            ii) Object.create:
                function foo(){}
                foo.prototype = {
                    foo_prop: "foo val"
                };
                function bar(){}
                var proto = Object.create(
                    foo.prototype
                );
                proto.bar_prop = "bar val";
                bar.prototype = proto;
                var inst = new bar;
                console.log(inst.foo_prop);
                console.log(inst.bar_prop);


                function foo(){}
                foo.prototype = {
                    foo_prop: "foo val"
                };
                function bar(){}
                var proto = Object.create(
                    foo.prototype,
                    {
                        bar_prop: {
                        value: "bar val"
                        }
                    }
                );
                bar.prototype = proto;
                var inst = new bar;
                console.log(inst.foo_prop);
                console.log(inst.bar_prop)

            iii) Object.setPrototypeOf():
                    function foo(){}
                    foo.prototype = {
                        foo_prop: "foo val"
                    };
                    function bar(){}
                    var proto = {
                        bar_prop: "bar val"
                    };
                    Object.setPrototypeOf(
                        proto, foo.prototype
                    );
                    bar.prototype = proto;
                    var inst = new bar;
                    console.log(inst.foo_prop);
                    console.log(inst.bar_prop);


                    function foo(){}
                    foo.prototype = {
                        foo_prop: "foo val"
                    };
                    function bar(){}
                    var proto;
                    proto=Object.setPrototypeOf(
                        { bar_prop: "bar val" },
                        foo.prototype
                    );
                    bar.prototype = proto;
                    var inst = new bar;
                    console.log(inst.foo_prop);
                    console.log(inst.bar_prop);

            iv) __proto__:
                function foo(){}
                foo.prototype = {
                    foo_prop: "foo val"
                };
                function bar(){}
                var proto = {
                    bar_prop: "bar val",
                    __proto__: foo.prototype
                };
                bar.prototype = proto;
                var inst = new bar;
                console.log(inst.foo_prop);
                console.log(inst.bar_prop);

                var inst = {
                    __proto__: {
                        bar_prop: "bar val",
                        __proto__: {
                        foo_prop: "foo val",
                        __proto__: Object.prototype
                        }
                    }
                };
                console.log(inst.foo_prop);
                console.log(inst.bar_prop);

        prototype & Object.getPrototypeOf():
            If, you do var a1 = new A(); var a2 = new A(); then a1.doSomething would actually refer to Object.getPrototypeOf(a1).doSomething, which is the same as the A.prototype.doSomething you defined, i.e. Object.getPrototypeOf(a1).doSomething == Object.getPrototypeOf(a2).doSomething == A.prototype.doSomething.

            [[Prototype]] is looked at recursively, i.e. a1.doSomething, Object.getPrototypeOf(a1).doSomething, Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething etc., until it's found or Object.getPrototypeOf returns null.
            Eg: var o = new Foo();

                //JavaScript actually just does
                var o = new Object();
                o.[[Prototype]] = Foo.prototype;
                Foo.call(o);

                //(or something like that) and when you later do
                o.someProp;

    Indexing object properties: You can refer to a property of an object either by its property name or by its ordinal index. If you initially define a property by its name, you must always refer to it by its name, and if you initially define a property by an index, you must always refer to it by its index.
        This restriction applies when you create an object and its properties with a constructor function (as we did previously with the Car object type) and when you define individual properties explicitly (for example, myCar.color = "red"). If you initially define an object property with an index, such as myCar[5] = "25 mpg", you subsequently refer to the property only as myCar[5].

    Defining objects for an object type: You can add a property to a previously defined object type by using the prototype property.
        Eg: Car.prototype.color = null;
            car1.color = 'black';

    Defining methods: Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object
        Eg: objectName.methodname = functionName;
            var myObj = {
                myMethod: function(params) {
                    // ...do something
                }

                // OR THIS WORKS TOO

                myOtherMethod(params) {
                    // ...do something else
                }
            };

            //Then to call the method:
            object.methodname(params);

    Using this for object references:
        const Manager = {
            name: "John",
            age: 27,
            job: "Software Engineer"
        }
        const Intern= {
            name: "Ben",
            age: 21,
            job: "Software Engineer Intern"
        }

        function sayHi() {
            console.log('Hello, my name is', this.name)
        }

        // add sayHi function to both objects
        Manager.sayHi = sayHi;
        Intern.sayHi = sayHi; 

        Manager.sayHi() // Hello, my name is John'
        Intern.sayHi() // Hello, my name is Ben'

    Defining getters & setters:
        i) var o = {
            a: 7,
            get b() { 
                return this.a + 1;
            },
            set c(x) {
                this.a = x / 2;
            }
        };

        console.log(o.a); // 7
        console.log(o.b); // 8
        o.c = 50;
        console.log(o.a); // 25

        The o object's properties are:
            o.a — a number
            o.b — a getter that returns o.a plus 1
            o.c — a setter that sets the value of o.a to half of the value o.c is being set to

        ii) var o = { a: 0 };
            Object.defineProperties(o, {
                'b': { get: function() { return this.a + 1; } },
                'c': { set: function(x) { this.a = x / 2; } }
            });

            o.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
            console.log(o.b); // Runs the getter, which yields a + 1 or 6

    Deleting properties: You can remove a non-inherited property by using the delete operator. The following code shows how to remove a property.
        // Creates a new object, myobj, with two properties, a and b.
        var myobj = new Object;
        myobj.a = 5;
        myobj.b = 12;

        // Removes the a property, leaving myobj with only the b property.
        delete myobj.a;
        console.log ('a' in myobj); // output: "false"

    Comparing objects: In JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.
        // Two variables, two distinct objects with the same properties
        var fruit = {name: 'apple'};
        var fruitbear = {name: 'apple'};

        fruit == fruitbear; // return false
        fruit === fruitbear; // return false
        // Two variables, a single object
        var fruit = {name: 'apple'};
        var fruitbear = fruit;  // Assign fruit object reference to fruitbear

        // Here fruit and fruitbear are pointing to same object
        fruit == fruitbear; // return true
        fruit === fruitbear; // return true

        fruit.name = 'grape';
        console.log(fruitbear); // output: { name: "grape" }, instead of { name: "apple" }

    To convert to JSON and then back to object: 
        // returns "{"physics":98,"maths":95,"chemistry":91}"
        JSON.stringify(marks);
        // Get object from string
        JSON.parse('{"physics":98,"maths":95,"chemistry":91}');

    Some important functions:
        i) Object.keys
        ii) Object.values
        iii) Object.prototype(object)
                It has many further methods:
                    Object.prototype.instanceof
                    Object.prototype.hasOwnProperty
        iv) Object.freeze(function): It freezes and object so that the object properties cannot be modified
            Eg: var marks = {physics: 98, maths:95, chemistry: 91};
                finalizedMarks = Object.freeze(marks);
                finalizedMarks["physics"] = 86; // throws error in strict mode
                console.log(marks); // {physics: 98, maths: 95, chemistry: 91}
                Object.isFrozen(finalizedMarks); // returns true
        v) Object.seal(function): is slightly different from the freeze. It allows configurable properties but won’t allow new property addition or deletion or properties.
            Eg: var marks = {physics: 98, maths:95, chemistry: 91};
                Object.seal(marks);
                delete marks.chemistry; // returns false as operation failed
                marks.physics = 95; // Works!
                marks.greek = 86; // Will not add a new property
                Object.isSealed(marks); // returns true

15. Lodash: It is a library which provides utility functions for common programming tasks. It makes javascript easier to work with arrays, object etc.

16. Array: 
    Common operations
        i)  Create an Array
            let fruits = ['Apple', 'Banana']
            console.log(fruits.length)
            // 2

        ii) Access (index into) an Array item
            let first = fruits[0]
            // Apple
            let last = fruits[fruits.length - 1]
            // Banana

        iii) Loop over an Array
            fruits.forEach(function(item, index, array) {
                console.log(item, index)
            })
            // Apple 0
            // Banana 1

        iv) Add to the end of an Array
            let newLength = fruits.push('Orange')
            // ["Apple", "Banana", "Orange"]
        v) Remove from the end of an Array
            let last = fruits.pop() // remove Orange (from the end)
            // ["Apple", "Banana"]
        vi) Remove from the front of an Array
            let first = fruits.shift() // remove Apple from the front
            // ["Banana"]
        vii) Add to the front of an Array
            let newLength = fruits.unshift('Strawberry') // add to the front
            // ["Strawberry", "Banana"]
        viii) Find the index of an item in the Array
            fruits.push('Mango')
            // ["Strawberry", "Banana", "Mango"]
            let pos = fruits.indexOf('Banana')
            // 1
        ix) Remove an item by index position
            let removedItem = fruits.splice(pos, 1) // this is how to remove an item    
            // ["Strawberry", "Mango"]
        x)  Remove items from an index position
            let vegetables = ['Cabbage', 'Turnip', 'Radish', 'Carrot']
            console.log(vegetables)
            // ["Cabbage", "Turnip", "Radish", "Carrot"]

            let pos = 1
            let n = 2

            let removedItems = vegetables.splice(pos, n)
            // this is how to remove items, n defines the number of items to be removed,
            // starting at the index position specified by pos and progressing toward the end of array.

            console.log(vegetables)
            // ["Cabbage", "Carrot"] (the original array is changed)

            console.log(removedItems)
            // ["Turnip", "Radish"]

        xi) Copy an Array
            let shallowCopy = fruits.slice() // this is how to make a copy
            // ["Strawberry", "Mango"]

    Accessing array elements: 
        Eg: let years = [1950, 1960, 1970, 1980, 1990, 2000, 2010]
            console.log(years.0)   // a syntax error
            console.log(years[0])  // 1950

            console.log(years['2']) // 1970
            console.log(years['02']) // 1970

    Relationship between length & numerical properties:
        const fruits = []
        fruits.push('banana', 'apple', 'peach')

        console.log(fruits.length)  // 3

        fruits[5]='mango';

        console.log(fruits)         // ['banana', 'apple', 'peach', empty, empty, 'mango']      //6

        fruits.length = 10

        console.log(fruits)         // ['banana', 'apple', 'peach', empty, empty, 'mango', empty, empty, empty, empty]  //10

        fruits.length = 2

        console.log(fruits)         // ['banana', 'apple']      //2

    Creating an array using a result of the match:
        Eg: // Match one d followed by one or more b's followed by one d
            // Remember matched b's and the following d
            // Ignore case

            const myRe = /d(b+)(d)/i
            const myArray = myRe.exec('cdbBdbsbz')

            console.log(myArray);           // ["dbBd", "bB", "d", index: 1, input: "cdbBdbsbz", groups: undefined]

            input (Read only): The original string against which the regular expression was matched. // cdbBdbsbz
            index (Read only): The zero-based index of the match in the string. // 1
            [0] (Read only): The last matched characters
            [1]....[n] (Read only): Elements that specify the parenthesized substring matches (if included) in the regular expression. The number of possible parenthesized substrings is unlimited. // [1]: "bB", [2]: "d"

    Constructors: Array() - creates array object

    Static properties: get Array(@@species): returns array constructor
                    Array.length

    Static methods:
        i) Array.from(array, optional function): Creates an array from array like instance.
            Eg: let a = Array.from('foo');
                console.log(a);             // ["f", "o", "o"]

                let b = Array.from([1,2,3], x => x+x);
                console.log(b);             // [2, 4, 6]

        ii) Array.isArray(value): Checks whether the given value is an array or not.
            Eg: Array.isArray(a);           // true

        iii) Array.of(value1, value2 ...): Creates an array of specified values.
                Eg: Array.of(7);        //  [7]
                    Array.of(1,2,3)     //  [1, 2, 3]

                    Array(7)            // Empty array of 7 spaces
                    Array.of(1,2,3)     //  [1, 2, 3]

                The difference between Array.of & Array is that when a single argument is provided then array.of creates the array with that value and array creates an array with that number of spaces.

    Array instances: Array instances can be inherited from Array.prototype. You can add new methods to all Array objects. This is used for polyfilling.
        Little known fact: Array.prototype itself is an Array:
            Array.isArray(Array.prototype) // true

    Instance properties:
        Array.prototype.constructor: Specifies the function that creates an object's prototype.
        Array.prototype.length: Reflects the number of elements in an array.
        Array.prototype[@@unscopables]: A symbol containing property names to exclude from a with binding scope.

    Instance methods:
        Mutator methods: These methods modify the array
            i) Array.prototype.copyWithin(target, start, end): Copies a sequence of array elements within the array.
                Eg: const array1 = ['a', 'b', 'c', 'd', 'e'];

                    // copy to index 0 the element at index 3
                    console.log(array1.copyWithin(0, 3, 5));
                    // expected output: Array ["d", "e", "c", "d", "e"]

                    // copy to index 1 all elements from index 3 to the end
                    console.log(array1.copyWithin(1, 3));
                    // expected output: Array ["d", "d", "e", "d", "e"]

            ii) Array.prototype.fill(value, start, end): Fills all the elements of an array from a start index to an end index with a static value.
                Eg: const array1 = [1, 2, 3, 4];

                    // fill with 0 from position 2 until position 4
                    console.log(array1.fill(0, 2, 4));
                    // expected output: [1, 2, 0, 0]

                    // fill with 5 from position 1
                    console.log(array1.fill(5, 1));
                    // expected output: [1, 5, 5, 5]

                    console.log(array1.fill(6));
                    // expected output: [6, 6, 6, 6]

            iii) Array.prototype.pop(): Removes the last element from an array and returns that element.
                Eg: const plants = ['broccoli', 'cauliflower', 'cabbage', 'kale', 'tomato'];

                    console.log(plants.pop());
                    // expected output: "tomato"

                    console.log(plants);
                    // expected output: Array ["broccoli", "cauliflower", "cabbage", "kale"]

                    plants.pop();

                    console.log(plants);
                    // expected output: Array ["broccoli", "cauliflower", "cabbage"]

            iv) Array.prototype.push(element1[, ...[, elementN]]): Adds one or more elements to the end of an array, and returns the new length of the array.
                Eg: const animals = ['pigs', 'goats', 'sheep'];

                    const count = animals.push('cows');
                    console.log(count);
                    // expected output: 4
                    console.log(animals);
                    // expected output: Array ["pigs", "goats", "sheep", "cows"]

                    animals.push('chickens', 'cats', 'dogs');
                    console.log(animals);
                    // expected output: Array ["pigs", "goats", "sheep", "cows", "chickens", "cats", "dogs"]

            v) Array.prototype.reverse(): Reverses the order of the elements of an array in place. (First becomes the last, last becomes first.)
                Eg: const array1 = ['one', 'two', 'three'];
                    console.log('array1:', array1);
                    // expected output: "array1:" Array ["one", "two", "three"]

                    const reversed = array1.reverse();
                    console.log('reversed:', reversed);
                    // expected output: "reversed:" Array ["three", "two", "one"]

                    // Careful: reverse is destructive -- it changes the original array.
                    console.log('array1:', array1);
                    // expected output: "array1:" Array ["three", "two", "one"]
            
            vi) Array.prototype.shift(): Removes the first element from an array and returns that element.
                Eg: const array1 = [1, 2, 3];

                    const firstElement = array1.shift();

                    console.log(array1);
                    // expected output: Array [2, 3]

                    console.log(firstElement);
                    // expected output: 1
            
            vii) Array.prototype.sort(): Sorts the elements of an array in place and returns the array. Its only for strings.
                Eg: const months = ['March', 'Jan', 'Feb', 'Dec'];
                    months.sort();
                    console.log(months);
                    // expected output: Array ["Dec", "Feb", "Jan", "March"]

                    const array1 = [1, 30, 4, 21, 100000];
                    array1.sort();
                    console.log(array1);
                    // expected output: Array [1, 100000, 21, 30, 4]
            
            viii) Array.prototype.splice(start, deleteCount, [item1, item2, ...]): Adds and/or removes elements from an array.
                Eg: const months = ['Jan', 'March', 'April', 'June'];
                    months.splice(1, 0, 'Feb');
                    // inserts at index 1
                    console.log(months);
                    // expected output: Array ["Jan", "Feb", "March", "April", "June"]

                    months.splice(4, 1, 'May');
                    // replaces 1 element at index 4
                    console.log(months);
                    // expected output: Array ["Jan", "Feb", "March", "April", "May"]
            
            ix) Array.prototype.unshift(element1, ..., elementN): Adds one or more elements to the front of an array, and returns the new length of the array.
                Eg: const array1 = [1, 2, 3];

                    console.log(array1.unshift(4, 5));
                    // expected output: 5

                    console.log(array1);
                    // expected output: Array [4, 5, 1, 2, 3]

        Accessor methods: These methods do not modify the original array/arrays but returns a new array.
            i) Array.prototype.concat([value1[, value2[, ...[, valueN]]]]): Returns a new array that is this array joined with other array(s) and/or value(s).
                Eg: const array1 = ['a', 'b', 'c'];
                    const array2 = ['d', 'e', 'f'];
                    const array3 = array1.concat(array2);

                    console.log(array3);
                    // expected output: Array ["a", "b", "c", "d", "e", "f"]

            ii) Array.prototype.filter(callbackFn(element[, index[, array]])[, thisArg]): Returns a new array containing all elements of the calling array for which the provided filtering callbackFn returns true.
                Eg: const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

                    const result = words.filter(word => word.length > 6);

                    console.log(result);
                    // expected output: Array ["exuberant", "destruction", "present"]

            iii) Array.prototype.includes(valueToFind[, fromIndex]): Determines whether the array contains valueToFind, returning true or false as appropriate.
                Eg: const array1 = [1, 2, 3];

                    console.log(array1.includes(2));
                    // expected output: true

                    const pets = ['cat', 'dog', 'bat'];

                    console.log(pets.includes('cat'));
                    // expected output: true

                    console.log(pets.includes('at'));
                    // expected output: false

            iv) Array.prototype.indexOf(searchElement[, fromIndex]): Returns the first (least) index of an element within the array equal to searchElement, or -1 if none is found.
                Eg: const beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];

                    console.log(beasts.indexOf('bison'));
                    // expected output: 1

                    // start from index 2
                    console.log(beasts.indexOf('bison', 2));
                    // expected output: 4

                    console.log(beasts.indexOf('giraffe'));
                    // expected output: -1

            v) Array.prototype.join([separator]): Joins all elements of an array into a string.
                Eg: const elements = ['Fire', 'Air', 'Water'];

                    console.log(elements.join());
                    // expected output: "Fire,Air,Water"

                    console.log(elements.join(''));
                    // expected output: "FireAirWater"

                    console.log(elements.join('-'));
                    // expected output: "Fire-Air-Water"

            vi) Array.prototype.lastIndexOf(searchElement[, fromIndex]): Returns the last (greatest) index of an element within the array equal to searchElement, or -1 if none is found.
                Eg: const animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo'];

                    console.log(animals.lastIndexOf('Dodo'));
                    // expected output: 3

                    console.log(animals.lastIndexOf('Tiger'));
                    // expected output: 1

            vii) Array.prototype.slice([begin[, end]]): Extracts a section of the calling array and returns a new array.
                Eg: const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];

                    console.log(animals.slice(2));
                    // expected output: Array ["camel", "duck", "elephant"]

                    console.log(animals.slice(2, 4));
                    // expected output: Array ["camel", "duck"]

                    console.log(animals.slice(1, 5));
                    // expected output: Array ["bison", "camel", "duck", "elephant"]

            viii) Array.prototype.toSource(): Returns an array literal representing the specified array. You can use this value to create a new array. Overrides the Object.prototype.toSource() method. This method should not be used facing the browsers as it wont work for every user.
                Eg: function Array() {
                        [native code]
                    }

            ix) Array.prototype.toString(): Returns a string representing the array and its elements. Overrides the Object.prototype.toString() method.
                Eg: const array1 = [1, 2, 'a', '1a'];

                    console.log(array1.toString());
                    // expected output: "1,2,a,1a"

            x) Array.prototype.toLocaleString(): Returns a localized string representing the array and its elements. Overrides the Object.prototype.toLocaleString() method.
                Eg: const array1 = [1, 'a', new Date('21 Dec 1997 14:12:00 UTC')];
                    const localeString = array1.toLocaleString('en', {timeZone: "UTC"});

                    console.log(localeString);
                    // expected output: "1,a,12/21/1997, 2:12:00 PM",
                    // This assumes "en" locale and UTC timezone - your results may vary

        Iterator methods: Several methods accept callback functions which are executed while processing the array. When these methods are called, the length of the array is sampled, and any element added beyond this length from within the callback is not visited. Other changes to the array (setting a value or deleting an element) may affect the results of the operation if the method visits the changed element afterwards. 
            If you must mutate the array, copy into a new array instead.

            i) Array.prototype.entries(): Returns a new Array Iterator object that contains the key/value pairs for each index in the array.
                Eg: const iterator1 = array1.entries();

                    console.log(iterator1.next().value);
                    // expected output: Array [0, "a"]

                    console.log(iterator1.next());
                    // expected output: Object { value: Array [1, "b"], done: false }

                    console.log(iterator1.next().value);
                    // expected output: Array [2, "c"]
                
                Eg: var a = ['a', 'b', 'c'];
                    var iterator = a.entries();

                    for (let e of iterator) {
                        console.log(e);
                    }
                    // [0, 'a']
                    // [1, 'b']
                    // [2, 'c'] 

            ii) Array.prototype.every(callbackFn(element[, index[, array]])[, thisArg]): Returns true if every element in this array satisfies the testing callbackFn.
                Eg: const isBelowThreshold = (currentValue) => currentValue < 40;

                    const array1 = [1, 30, 39, 29, 10, 13];

                    console.log(array1.every(isBelowThreshold));
                    // expected output: true

                Eg: // ---------------
                    // Modifying items
                    // ---------------
                    let arr = [1, 2, 3, 4];
                    arr.every( (elem, index, arr) => {
                        arr[index+1] -= 1
                        console.log(`[${arr}][${index}] -> ${elem}`)
                        return elem < 2 
                    })

                    // Loop runs for 3 iterations, but would 
                    // have run 2 iterations without any modification
                    //
                    // 1st iteration: [1,1,3,4][0] -> 1
                    // 2nd iteration: [1,1,2,4][1] -> 1
                    // 3rd iteration: [1,1,2,3][2] -> 2

                Eg: // ---------------
                    // Appending items
                    // ---------------
                    arr = [1, 2, 3];
                    arr.every( (elem, index, arr) => {
                    arr.push('new')
                    console.log(`[${arr}][${index}] -> ${elem}`)
                    return elem < 4
                    })

                    // Loop runs for 3 iterations, even after appending new items
                    //
                    // 1st iteration: [1, 2, 3, new][0] -> 1
                    // 2nd iteration: [1, 2, 3, new, new][1] -> 2
                    // 3rd iteration: [1, 2, 3, new, new, new][2] -> 3

                Eg: // ---------------
                    // Deleting items
                    // ---------------
                    arr = [1, 2, 3, 4];
                    arr.every( (elem, index, arr) => {
                    arr.pop()
                    console.log(`[${arr}][${index}] -> ${elem}`)
                    return elem < 4
                    })

                    // Loop runs for 2 iterations only, as the remaining 
                    // items are `pop()`ed off
                    //
                    // 1st iteration: [1,2,3][0] -> 1
                    // 2nd iteration: [1,2][1] -> 2

            iii) Array.prototype.find(callbackFn(element[, index[, array]])[, thisArg]): Returns the found element in the array if some element in the array satisfies the testing callbackFn, or undefined if not found.
                Eg: const array1 = [5, 12, 8, 130, 44];

                    const found = array1.find(element => element > 10);

                    console.log(found);
                    // expected output: 12

                Eg: Finding a prime number
                    function isPrime(element, index, array) {
                        let start = 2;
                        while (start <= Math.sqrt(element)) {
                            if (element % start++ < 1) {
                                return false;
                            }
                        }
                        return element > 1;
                    }

                    console.log([4, 6, 8, 12].find(isPrime)); // undefined, not found
                    console.log([4, 5, 8, 12].find(isPrime)); // 5

            iv) Array.prototype.findIndex(callbackFn(element[, index[, array]])[, thisArg]): Returns the found index in the array, if an element in the array satisfies the testing callbackFn, or -1 if not found.
                Eg: const array1 = [5, 12, 8, 130, 44];

                    const isLargeNumber = (element) => element > 13;

                    console.log(array1.findIndex(isLargeNumber));
                    // expected output: 3

                Eg: function isPrime(element) {
                        let start = 2;
                        while (start <= Math.sqrt(element)) {
                            if (element % start < 1) {
                                return false;
                            } else {
                                start++;
                            }
                        }
                        return element > 1;
                    }

                    console.log([4, 6, 8, 12].findIndex(isPrime)); // -1, not found
                    console.log([4, 6, 7, 12].findIndex(isPrime)); // 2 (array[2] is 7)

            v) Array.prototype.forEach(callbackFn(currentValue[, index[, array]])[, thisArg]): Calls a callbackFn for each element in the array. There is no way to stop or break forEach method in between other than th
                Eg: const array1 = ['a', 'b', 'c'];

                    array1.forEach(element => console.log(element));

                    // expected output: "a"
                    // expected output: "b"
                    // expected output: "c"

                Eg: No operation for uninitialized values (sparse arrays)
                    const arraySparse = [1,3,,7]
                    let numCallbackRuns = 0

                    arraySparse.forEach(function(element){
                        console.log(element)
                        numCallbackRuns++
                    })

                    console.log("numCallbackRuns: ", numCallbackRuns)

                    // 1
                    // 3
                    // 7
                    // numCallbackRuns: 3
                    // comment: as you can see the missing value between 3 and 7 didn't invoke callback function.

                Eg: Using thisArg
                    The following (contrived) example updates an object's properties from each entry in the array:

                    function Counter() {
                        this.sum = 0
                        this.count = 0
                    }
                    Counter.prototype.add = function(array) {
                        array.forEach(function(entry) {
                            this.sum += entry
                            ++this.count
                        }, this)
                        // ^---- Note
                    }

                    const obj = new Counter()
                    obj.add([2, 5, 9])
                    obj.count
                    // 3 
                    obj.sum
                    // 16
                    // Since the thisArg parameter (this) is provided to forEach(), it is passed to callback each time it's invoked. The callback uses it as its this value.
                
                Eg: Copying an object
                    function copy(obj) {
                        const copy = Object.create(Object.getPrototypeOf(obj))
                        const propNames = Object.getOwnPropertyNames(obj)

                        propNames.forEach(function(name) {
                            const desc = Object.getOwnPropertyDescriptor(obj, name)
                            Object.defineProperty(copy, name, desc)
                        })

                        return copy
                    }

                    const obj1 = { a: 1, b: 2 }
                    const obj2 = copy(obj1)      // obj2 looks like obj1 now

                Eg: Note on using Promises or async functions
                    let ratings = [5, 4, 5]

                    let sum = 0

                    let sumFunction = async function (a, b)
                    {
                        return a + b
                    } 

                    ratings.forEach(async function(rating) {
                        sum = await sumFunction(sum, rating)
                    })

                    console.log(sum)
                    // Expected output: 14
                    // Actual output: 0

            vi) Array.prototype.keys(): Returns a new Array Iterator that contains the keys for each index in the array.
                Eg: const array1 = ['a', 'b', 'c'];
                    const iterator = array1.keys();

                    for (const key of iterator) {
                        console.log(key);
                    }

                    // expected output: 0
                    // expected output: 1
                    // expected output: 2

                Eg: // Key iterator doesn't ignore holes
                    var arr = ['a', , 'c'];
                    var sparseKeys = Object.keys(arr);
                    var denseKeys = [...arr.keys()];
                    console.log(sparseKeys); // ['0', '2']
                    console.log(denseKeys);  // [0, 1, 2]

            vii) Array.prototype.map(callbackFn(currentValue[, index[, array]])[, thisArg]): Returns a new array containing the results of calling callbackFn on every element in this array.
                Eg: const array1 = [1, 4, 9, 16];

                    // pass a function to map
                    const map1 = array1.map(x => x * 2);

                    console.log(map1);
                    // expected output: Array [2, 8, 18, 32]

                Eg: Using map to reformat objects in an array
                    let kvArray = [{key: 1, value: 10}, 
                                    {key: 2, value: 20}, 
                                    {key: 3, value: 30}]

                    let reformattedArray = kvArray.map(obj => {
                        let rObj = {}
                        rObj[obj.key] = obj.value
                        return rObj
                    })
                    // reformattedArray is now [{1: 10}, {2: 20}, {3: 30}], 

                    // kvArray is still: 
                    // [{key: 1, value: 10}, 
                    //  {key: 2, value: 20}, 
                    //  {key: 3, value: 30}]

                Eg: ["1", "2", "3"].map(parseInt)
                    //  [1, NaN, NaN]
                    ["1", "2", "3"].map(x => parseInt(x));
                    //  [1, 2, 3]

                Eg: Mapped array contains undefined
                    let numbers = [1, 2, 3, 4]
                    let filteredNumbers = numbers.map(function(num, index) {
                        if (index < 3) {
                            return num
                        }
                    })
                    // index goes from 0, so the filterNumbers are 1,2,3 and undefined.
                    // filteredNumbers is [1, 2, 3, undefined]
                    // numbers is still [1, 2, 3, 4]

            viii) Array.prototype.reduce(callbackFn(accumulator, currentValue[, index[, array]])[, initialValue]): Apply a callbackFn against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value.
                Eg: const array1 = [1, 2, 3, 4];
                    const reducer = (accumulator, currentValue) => accumulator + currentValue;

                    // 1 + 2 + 3 + 4
                    console.log(array1.reduce(reducer));
                    // expected output: 10

                    // 5 + 1 + 2 + 3 + 4
                    console.log(array1.reduce(reducer, 5));
                    // expected output: 15

                If intial value is provided then current index starts from 0 and accumulator is the initial value provided. If not then current index starts from 1 and accumulator becomes the value at 0 position of the array.

                Reduce works as following:
                    Eg 1: without the initial value
                        [0, 1, 2, 3, 4].reduce(function(accumulator, currentValue, currentIndex, array) {
                            return accumulator + currentValue
                        })

                        The callback would be invoked four times, with the arguments and return values in each call being as follows:

                        callback iteration	    accumulator	    currentValue	currentIndex	    array	    return value
                        first call	                0	            1	            1	        [0, 1, 2, 3, 4]	    1
                        second call	                1	            2	            2	        [0, 1, 2, 3, 4]	    3
                        third call	                3	            3	            3	        [0, 1, 2, 3, 4]	    6
                        fourth call	                6	            4	            4	        [0, 1, 2, 3, 4]	    10

                    Eg 2: With the initial value
                        [0, 1, 2, 3, 4].reduce((accumulator, currentValue, currentIndex, array) => {
                            return accumulator + currentValue
                        }, 10)
                        callback iteration	    accumulator	    currentValue	currentIndex	    array	        return value
                        first call	                10	            0	            0	        [0, 1, 2, 3, 4]	        10
                        second call	                10	            1	            1	        [0, 1, 2, 3, 4]	        11
                        third call	                11	            2	            2	        [0, 1, 2, 3, 4]	        13
                        fourth call	                13	            3	            3	        [0, 1, 2, 3, 4]	        16
                        fifth call	                16	            4	            4	        [0, 1, 2, 3, 4]	        20

                    Eg 3: Flatten an array of arrays:
                            let flattened = [[0, 1], [2, 3], [4, 5]].reduce(
                                function(accumulator, currentValue) {
                                    return accumulator.concat(currentValue)
                                },
                                []
                            )
                            // flattened is [0, 1, 2, 3, 4, 5]

                    Eg 4: Counting instances of values in an object
                            let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice']

                            let countedNames = names.reduce(function (allNames, name) { 
                                if (name in allNames) {
                                    allNames[name]++
                                }
                                else {
                                    allNames[name] = 1
                                }
                                return allNames
                            }, {})
                            // countedNames is:
                            // { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }

                    Eg 5: Grouping objects by a property
                        let people = [
                            { name: 'Alice', age: 21 },
                            { name: 'Max', age: 20 },
                            { name: 'Jane', age: 20 }
                        ];

                        function groupBy(objectArray, property) {
                            return objectArray.reduce(function (acc, obj) {
                                let key = obj[property]
                                if (!acc[key]) {
                                acc[key] = []
                                }
                                acc[key].push(obj)
                                return acc
                            }, {})
                        }

                        let groupedPeople = groupBy(people, 'age')
                        // groupedPeople is:
                        // { 
                        //   20: [
                        //     { name: 'Max', age: 20 }, 
                        //     { name: 'Jane', age: 20 }
                        //   ], 
                        //   21: [{ name: 'Alice', age: 21 }] 
                        // }

                    Eg 6: Remove duplicate items in array

                            let myArray = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd']
                            let myOrderedArray = myArray.reduce(function (accumulator, currentValue) {
                                if (accumulator.indexOf(currentValue) === -1) {
                                    accumulator.push(currentValue)
                                }
                                return accumulator
                            }, [])

                            console.log(myOrderedArray)

                    Eg 7: Running Promises in Sequence
                        /**
                        * Runs promises from array of functions that can return promises
                        * in chained manner
                        *
                        * @param {array} arr - promise arr
                        * @return {Object} promise object
                        */
                        function runPromiseInSequence(arr, input) {
                            return arr.reduce(
                                (promiseChain, currentFunction) => promiseChain.then(currentFunction),
                                Promise.resolve(input)
                            )
                        }

                        // promise function 1
                        function p1(a) {
                            return new Promise((resolve, reject) => {
                                resolve(a * 5)
                            })
                        }

                        // promise function 2
                        function p2(a) {
                            return new Promise((resolve, reject) => {
                                resolve(a * 2)
                            })
                        }

                        // function 3  - will be wrapped in a resolved promise by .then()
                        function f3(a) {
                            return a * 3
                        }

                        // promise function 4
                        function p4(a) {
                            return new Promise((resolve, reject) => {
                                resolve(a * 4)
                            })
                        }

                        const promiseArr = [p1, p2, f3, p4]
                        runPromiseInSequence(promiseArr, 10)
                            .then(console.log)   // 1200

                    Eg 8: Write map using reduce
                        if (!Array.prototype.mapUsingReduce) {
                            Array.prototype.mapUsingReduce = function(callback, thisArg) {
                                return this.reduce(function(mappedArray, currentValue, index, array) {
                                mappedArray[index] = callback.call(thisArg, currentValue, index, array)
                                return mappedArray
                                }, [])
                            }
                        }

                        [1, 2, , 3].mapUsingReduce(
                            (currentValue, index, array) => currentValue + index + array.length
                        ) // [5, 7, , 10]

            ix) Array.prototype.reduceRight(callbackFn(accumulator, currentValue[, index[, array]])[, initialValue]): Apply a callbackFn against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value.
                Eg: const array1 = [[0, 1], [2, 3], [4, 5]].reduceRight(
                        (accumulator, currentValue) => accumulator.concat(currentValue)
                    );

                    console.log(array1);
                    // expected output: Array [4, 5, 2, 3, 0, 1]

            x) Array.prototype.some(callbackFn(element[, index[, array]])[, thisArg]): Returns true if at least one element in this array satisfies the provided testing callbackFn. It doesnt mutate the array on which it is called.
                Eg: const array = [1, 2, 3, 4, 5];

                    // checks whether an element is even
                    const even = (element) => element % 2 === 0;

                    console.log(array.some(even));
                    // expected output: true

            xi) Array.prototype.values(): Returns a new Array Iterator object that contains the values for each index in the array.
                Eg: const array1 = ['a', 'b', 'c'];
                    const iterator = array1.values();

                    for (const value of iterator) {
                    console.log(value);
                    }

                    // expected output: "a"
                    // expected output: "b"
                    // expected output: "c"

            xii) Array.prototype[@@iterator](): Returns a new Array Iterator object that contains the values for each index in the array.
                Eg: // Iteration using for...of loop
                    var arr = ['a', 'b', 'c', 'd', 'e'];
                    var eArr = arr[Symbol.iterator]();
                    // your browser must support for..of loop
                    // and let-scoped variables in for loops
                    // const and var could also be used
                    for (let letter of eArr) {
                        console.log(letter);
                    }

                Eg: // Alternative iteration
                    var arr = ['a', 'b', 'c', 'd', 'e'];
                    var eArr = arr[Symbol.iterator]();
                    console.log(eArr.next().value); // a
                    console.log(eArr.next().value); // b
                    console.log(eArr.next().value); // c
                    console.log(eArr.next().value); // d
                    console.log(eArr.next().value); // e

                Eg: Use Case for brace notation: The use case for this syntax over using the dot notation (Array.prototype.values()) is in a case where you don't know what object is going to be ahead of time. If you have a function that takes an iterator and then iterate over the value, but don't know if that Object is going to have a [Iterable].prototype.values method. This could be a built-in object like String object or a custom object. 

                    function logIterable(it) {
                        var iterator = it[Symbol.iterator]();
                        // your browser must support for..of loop
                        // and let-scoped variables in for loops
                        // const and var could also be used
                        for (let letter of iterator) {
                            console.log(letter);
                        }
                    }

                    // Array
                    logIterable(['a', 'b', 'c']);
                    // a
                    // b
                    // c

                    // string
                    logIterable('abc'); 
                    // a
                    // b
                    // c

    Examples:

        i) Creating an array: The following example creates an array, msgArray, with a length of 0, then assigns values to msgArray[0] and msgArray[99], changing the length of the array to 100.

            let msgArray = []
            msgArray[0] = 'Hello'
            msgArray[99] = 'world'

            if (msgArray.length === 100) {
                console.log('The length is 100.')
            }

        ii) Creating a two-dimensional array
            The following creates a chess board as a two-dimensional array of strings. The first move is made by copying the 'p' in board[6][4] to board[4][4]. The old position at [6][4] is made blank.

            let board = [ 
            ['R','N','B','Q','K','B','N','R'],
            ['P','P','P','P','P','P','P','P'],
            [' ',' ',' ',' ',' ',' ',' ',' '],
            [' ',' ',' ',' ',' ',' ',' ',' '],
            [' ',' ',' ',' ',' ',' ',' ',' '],
            [' ',' ',' ',' ',' ',' ',' ',' '],
            ['p','p','p','p','p','p','p','p'],
            ['r','n','b','q','k','b','n','r'] ]

            console.log(board.join('\n') + '\n\n')

            // Move King's Pawn forward 2
            board[4][4] = board[6][4]
            board[6][4] = ' '
            console.log(board.join('\n'))
            Here is the output:

            R,N,B,Q,K,B,N,R
            P,P,P,P,P,P,P,P
            , , , , , , , 
            , , , , , , , 
            , , , , , , , 
            , , , , , , , 
            p,p,p,p,p,p,p,p
            r,n,b,q,k,b,n,r

            R,N,B,Q,K,B,N,R
            P,P,P,P,P,P,P,P
            , , , , , , , 
            , , , , , , , 
            , , , ,p, , , 
            , , , , , , , 
            p,p,p,p, ,p,p,p
            r,n,b,q,k,b,n,r

        iii) Using an array to tabulate a set of values:
                values = []
                for (let x = 0; x < 10; x++){
                    values.push([
                        2 ** x,
                        2 * x ** 2
                    ])
                }
                console.table(values)
                Results in

                0	1	0
                1	2	2
                2	4	8
                3	8	18
                4	16	32
                5	32	50
                6	64	72
                7	128	98
                8	256	128
                9	512	162
                (First column is the (index))

17. Callbacks, Promises, Asynchronous javascript, Synchronous javascript:
    Callbacks: A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.

        Here is a quick example:

        function greeting(name) {
            alert('Hello ' + name);
        }

        function processUserInput(callback) {
            var name = prompt('Please enter your name.');
            callback(name);
        }

        processUserInput(greeting);

        The above example is a synchronous callback, as it is executed immediately.

        Note, however, that callbacks are often used to continue code execution after an asynchronous operation has completed — these are called asynchronous callbacks. A good example is the callback functions executed inside a .then() block chained onto the end of a promise after that promise fulfills or rejects. This structure is used in many modern web APIs, such as fetch().

    Synchronous Javascript:
        const btn = document.querySelector('button');
        btn.addEventListener('click', () => {
            alert('You clicked me!');

            let pElem = document.createElement('p');
            pElem.textContent = 'This is a newly-added paragraph.';
            document.body.appendChild(pElem);
        });

        In this block, the lines are executed one after the other:

        - We grab a reference to a <button> element that is already available in the DOM.
        - We add a click event listener to it so that when the button is clicked:
        - An alert() message appears.
        - Once the alert is dismissed, we create a <p> element.
        - We then give it some text content.
        - Finally, we append the paragraph to the document body.

        This is because Javascript is single threaded and only one task can happen at a time. Other operations are blocked till the previous task is completed.

    Asynchronous Javascript:
        - access or fetch some kind of resource from an external device
                such as fetching a file from the network 
                accessing a database and returning data from it
                accessing a video stream from a web cam
                or broadcasting the display to a VR headset.

        Look at the following example:
            let response = fetch('myImage.png');
            let blob = response.blob();
            // display your image blob in the UI somehow

            You don't know how much time it is gonna take for the image to return and if it takes time your blob will be undefined. So you have to wait until the response comes.

        Blocking Code: When a web app runs in a browser and it executes an intensive chunk of code without returning control to the browser, the browser can appear to be frozen. This is called blocking; the browser is blocked from continuing to handle user input and perform other tasks until the web app returns control of the processor.
            Eg: const btn = document.querySelector('button');
                btn.addEventListener('click', () => {
                    let myDate;
                    for(let i = 0; i < 10000000; i++) {
                        let date = new Date();
                        myDate = date
                    }

                    console.log(myDate);

                    let pElem = document.createElement('p');
                    pElem.textContent = 'This is a newly-added paragraph.';
                    document.body.appendChild(pElem);
                });
        
        Threads: single process to do a task. Each task will be run sequentially; a task has to complete before the next one can be started.


        i) Async Callbacks: are the functions that are passed as arguments in a function. When called they start running in background and when it completes it returns a response to let you know the work is done.
            Eg: An example of an async callback is the second parameter of the addEventListener() method (as we saw in action above):

                btn.addEventListener('click', () => {
                    alert('You clicked me!');

                    let pElem = document.createElement('p');
                    pElem.textContent = 'This is a newly-added paragraph.';
                    document.body.appendChild(pElem);
                });

            When we pass a callback function as an argument to another function, we are only passing the function's reference as an argument, i.e, the callback function is not executed immediately. It is “called back” (hence the name) asynchronously somewhere inside the containing function’s body. The containing function is responsible for executing the callback function when the time comes.

            Eg: function loadAsset(url, type, callback) {
                    let xhr = new XMLHttpRequest();
                    xhr.open('GET', url);
                    xhr.responseType = type;

                    xhr.onload = function() {
                        callback(xhr.response);
                    };

                    xhr.send();
                }

                function displayImage(blob) {
                    let objectURL = URL.createObjectURL(blob);

                    let image = document.createElement('img');
                    image.src = objectURL;
                    document.body.appendChild(image);
                }

                loadAsset('coffee.jpg', 'blob', displayImage);

                In this case the callback is waiting on the XHR call to finish downloading the resource (using the onload event handler) before it passes it to the callback.

                Callbacks are versatile — not only do they allow you to control the order in which functions are run and what data is passed between them, they also allow you to pass data to different functions depending on circumstance. So you could have different actions to run on the response downloaded, such as processJSON(), displayText(), etc.

                Not all callbacks are async. Some run synchronously Eg: Array.prototype.forEach()

        ii) Promises: Promises are a modern way of async code. Eg: fetch(). Promise is an object that indicates the completion or error.  In essence, it's the browser's way of saying "I promise to get back to you with the answer as soon as I can," hence the name "promise."
            Eg: fetch('products.json').then(function(response) {
                    return response.json();
                }).then(function(json) {
                    products = json;
                    initialize();
                }).catch(function(err) {
                    console.log('Fetch problem: ' + err.message);
                });


            Generally we have got three blocks chained to the promise.
                * Two then() blocks: Both contain a callback function that will run when previous block returns some response. The response returned by the previous block will be the input parameter for the next block. We can chain many then() blocks together to make asynchronous calls.
                * One catch() block: When any then() block fails this is encountered

            The event queue: Async operations like promises are put into an event queue, which runs after the main thread has finished processing so that they do not block subsequent JavaScript code from running. The queued operations will complete as soon as possible then return their results to the JavaScript environment.

            Promises vs Callbacks:
                a) Promises are specifically made to handle async operations whereas callbacks can be coded in both sync and async operations.
                b) For many callbacks to call one after the other we create a callback inside a callback and so on. This becomes a messy pyramid of doom called as Callback hell. This is resolved by promises by using then() block.
                c) Errors in callback needs to be handled in every step whereas in Promises any error can be handled in .catch() block.
            
        The nature of asynchronous code: Lets study the following code:
            console.log ('Starting');
            let image;

            fetch('coffee.jpg').then((response) => {
                console.log('It worked :)')
                return response.blob();
            }).then((myBlob) => {
                let objectURL = URL.createObjectURL(myBlob);
                image = document.createElement('img');
                image.src = objectURL;
                document.body.appendChild(image);
            }).catch((error) => {
                console.log('There has been a problem with your fetch operation: ' + error.message);
            });

            console.log ('All done!');

            // Output:
            // Starting
            // All done!
            // It worked :)

        Cooperative asynchronous javascript:
            i) setTimeout(): executes the block of code after a specified time.
                Eg: let myGreeting = setTimeout(function() {
                        alert('Hello, Mr. Universe!');
                    }, 2000)

                The functions defined inside need not be anonymous but can be any type of function.

                Passing parameters to setTimeout:
                    Eg: function sayHi(who, where) {
                            alert(`Hello ${who}! ${where}`);
                        }
                        let myGreeting = setTimeout(sayHi, 2000, 'Mr. Universe', 'Delhi');

                Clearing timeouts:
                    Eg: clearTimeout(myGreeting);

            ii) setInterval(): executes the block of code after specified interval again and again.
                Eg: function displayTime() {
                        let date = new Date();
                        let time = date.toLocaleTimeString();
                        document.getElementById('demo').textContent = time;
                    }

                    const createClock = setInterval(displayTime, 1000);

                Clearing intervals: 
                    Eg: const myInterval = setInterval(myFunction, 2000);
                        clearInterval(myInterval);

            Source Code for stopwatch: https://github.com/mdn/learning-area/blob/master/javascript/asynchronous/loops-and-intervals/setinterval-stopwatch.html

            Recursive timeouts:
                There is another way to use setTimeout(): you can call it recursively to run the same code repeatedly, instead of using setInterval().
                Eg: let i = 1;
                    setTimeout(function run() {
                        console.log(i);
                        i++;
                        setTimeout(run, 100);
                    }, 100);

                    Compare the above example to the following one — this uses setInterval() to accomplish the same effect:
                    let i = 1;

                    setInterval(function run() {
                        console.log(i);
                        i++
                    }, 100);

                The difference between the two versions of the above code is a subtle one.
                    - Recursive setTimeout() guarantees the same delay between the executions. (For example, 100ms in the above case.) The code will run, then wait 100 milliseconds before it runs again—so the interval will be the same, regardless of how long the code takes to run.
                    - The example using setInterval() does things somewhat differently. The interval you chose includes the time taken to execute the code you want to run in. Let's say that the code takes 40 milliseconds to run — the interval then ends up being only 60 milliseconds.
                    - When using setTimeout() recursively, each iteration can calculate a different delay before running the next iteration. In other words, the value of the second parameter can specify a different time in milliseconds to wait before running the code again.

            Immediate Timeouts: When time is set to 0

            requestAnimationFrame():
                requestAnimationFrame() is a specialized looping function created for running animations efficiently in the browser. It is basically the modern version of setInterval() — it executes a specified block of code before the browser next repaints the display, allowing an animation to be run at a suitable frame rate regardless of the environment it is being run in.

        Graceful asynchronous programming with Promises: A very good example of promises would be of taking permissions in mobile application. No thing is done until user approves. Since the call is made on the main thread the whole application is paused until and unless the user responds with something which is not correct. So using promise we handle this situation that application thread is not blocked and the application enables the item when the user responds with the permissions. Till then rest of the application keeps working.
            The code that the video chat application would use might look something like this:
                function handleCallButton(evt) {
                    setStatusMessage("Calling...");
                    navigator.mediaDevices.getUserMedia({video: true, audio: true})
                        .then(chatStream => {
                        selfViewElem.srcObject = chatStream;
                        chatStream.getTracks().forEach(track => myPeerConnection.addTrack(track, chatStream));
                        setStatusMessage("Connected");
                        }).catch(err => {
                        setStatusMessage("Failed to connect");
                        });
                }

            The trouble with callbacks:
                Eg: chooseToppings(function(toppings) {
                        placeOrder(toppings, function(order) {
                            collectOrder(order, function(pizza) {
                            eatPizza(pizza);
                            }, failureCallback);
                        }, failureCallback);
                    }, failureCallback);

                Eg: chooseToppings()
                    .then(function(toppings) {
                        return placeOrder(toppings);
                    })
                    .then(function(order) {
                        return collectOrder(order);
                    })
                    .then(function(pizza) {
                        eatPizza(pizza);
                    })
                    .catch(failureCallback);

            A successful return in Promise is said to be resolved. And unsuccessful return in Promise is said to be rejected.

            Promise.all(): we can chain many promises together i.e. until all promises return the code execution wont shift to next line.
                Eg: Promise.all([a, b, c]).then(values => {
                        ...
                    }); // a,b,c are promises

            In modern browsers there is also a finally() present which can be used Promise.all to check if the promise has returned or not.

            Note: then()/catch()/finally() is the async equivalent to try/catch/finally in sync code.

            Promise constructor: 
                Eg: Resolving a promise
                    let timeoutPromise = new Promise((resolve, reject) => {
                        setTimeout(function(){
                            resolve('Success!');
                        }, 2000);
                    });

                    timeoutPromise
                    .then((message) => {
                        alert(message);
                    })

                Eg: Rejecting a promise
                    function timeoutPromise(message, interval) {
                        return new Promise((resolve, reject) => {
                            if (message === '' || typeof message !== 'string') {
                            reject('Message is empty or not a string');
                            } else if (interval < 0 || typeof interval !== 'number') {
                            reject('Interval is negative or not a number');
                            } else {
                            setTimeout(function(){
                                resolve(message);
                            }, interval);
                            }
                        });
                    };

                Eg: function promisifyRequest(request) {
                        return new Promise(function(resolve, reject) {
                            request.onsuccess = function() {
                            resolve(request.result);
                            };

                            request.onerror = function() {
                            reject(request.error);
                            };
                        });
                    }

                    * When the request's success event fires, the onsuccess handler fulfills the promise with the request result.
                    * When the request's error event fires, the onerror handler rejects the promise with the request error.

        Async/Await:
            i) Async:
                async function hello() { return "Hello" };
                hello();

                To actually consume the value returned when the promise fulfills, since it is returning a promise, we could use a .then() block:

                hello().then((value) => console.log(value))

            ii) Await: await can be put in front of any async promised based function. It pauses the code until the promise returns the value. It only works inside an async function
                Eg: async function hello() {
                        return greeting = await Promise.resolve("Hello");
                    };

                    hello().then(alert);

        Promises with async/await:
            Eg: async function myFetch() {
                    let response = await fetch('coffee.jpg');
                    return await response.blob();
                }

                myFetch().then((blob) => {
                    let objectURL = URL.createObjectURL(blob);
                    let image = document.createElement('img');
                    image.src = objectURL;
                    document.body.appendChild(image);
                }).catch(e => console.log(e));

        Downside of async/await:
            i) It makes the code look synchronous and also by its behaviour because it blocks the code until the response is returned. Though the other code will still be working in the background. So many awaits together can make the code slow.
            ii) Another minor inconvenience is that you have to wrap your awaited promises inside an async function.

        Async/Await class methods: We can even add async await inside class methods.
            
18. Observables: .next(), .complete(), .error(), .subscribe({}), .unsubscribe()
        * A Function is a lazily evaluated computation that synchronously returns a single value on invocation.
        * A generator is a lazily evaluated computation that synchronously returns zero to (potentially) infinite values on iteration.
        * A Promise is a computation that may (or may not) eventually return a single value.
        * An Observable is a lazily evaluated computation that can synchronously or asynchronously return zero to (potentially) infinite values from the time it's invoked onwards.

        Observables are like functions with zero arguments, but generalize those to allow multiple values.
        Observables can be synchronous as well as asynchronous.
        Synchronous:
            Eg1)    function foo() {
                        console.log('Hello');
                        return 42;
                    }

                    const x = foo.call(); // same as foo()
                    console.log(x);
                    const y = foo.call(); // same as foo()
                    console.log(y);

                    //output:
                    "Hello"
                    42
                    "Hello"
                    42

                You can write the same behavior above, but with Observables:

                    import { Observable } from 'rxjs';
                    
                    const foo = new Observable(subscriber => {
                        console.log('Hello');
                        subscriber.next(42);
                    });
                    
                    foo.subscribe(x => {
                        console.log(x);
                    });
                    foo.subscribe(y => {
                        console.log(y);
                    });

                    //And the output is the same:

                    "Hello"
                    42
                    "Hello"
                    42

        A difference between a function and an Observable is that an Observable can return multiple values which function cannot.

        Asynchronous:
            Eg 1)   import { Observable } from 'rxjs';
 
                    const foo = new Observable(subscriber => {
                        console.log('Hello');
                        subscriber.next(42);
                        subscriber.next(100);
                        subscriber.next(200);
                        setTimeout(() => {
                            subscriber.next(300); // happens asynchronously
                        }, 1000);
                    });
                    
                    console.log('before');
                    foo.subscribe(x => {
                        console.log(x);
                    });
                    console.log('after');

                    With output:
                    "before"
                    "Hello"
                    42
                    100
                    200
                    "after"
                    300

        There are three types of values an Observable Execution can deliver:
            - "Next" notification: sends a value such as a Number, a String, an Object, etc.
            - "Error" notification: sends a JavaScript Error or exception.
            - "Complete" notification: does not send a value.

        Eg: import { Observable } from 'rxjs';
            const observable = new Observable(function subscribe(subscriber) {
            subscriber.next(1);
            subscriber.next(2);
            subscriber.next(3);
            subscriber.complete();
            subscriber.next(4); // Is not delivered because it would violate the contract
            });


        Eg: import { Observable } from 'rxjs';
            const observable = new Observable(function subscribe(subscriber) {
                try {
                    subscriber.next(1);
                    subscriber.next(2);
                    subscriber.next(3);
                    subscriber.complete();
                } catch (err) {
                    subscriber.error(err); // delivers an error if it caught one
                }
            });

        Eg: import { from } from 'rxjs';
            const observable = from([10, 20, 30]);
            const subscription = observable.subscribe(x => console.log(x));

            // Later:
            subscription.unsubscribe();

        Eg: function subscribe(subscriber) {
                const intervalId = setInterval(() => {
                    subscriber.next('hi');
                }, 1000);
                
                return function unsubscribe() {
                    clearInterval(intervalId);
                };
            }
 
            const unsubscribe = subscribe({next: (x) => console.log(x)});
            
            // Later:
            unsubscribe(); // dispose the resources

19. Promise vs Obeservables:
    i) Promise is eager as the next callback function is executed immediately. Observable is lazy as it needs to be invoked inside subscribe to be called.
    ii) Observable can be synchronous as well asynchronous whereas promise will only be asynchronous.
    iii) Promises provide a single value or object but Observables can return multiple values.

20. undefined vs null:
    i) null: null is non-existent or empty value. It has to be assigned
        Eg: let a = null;
            console.log(a);
            // null        
    ii) undefined: undefined typically means that variable has been declared but not defined.
        Eg: let b;
            console.log(b);
            // undefined 

        You can also explicitly set a variable to equal undefined:
            let c = undefined;
            console.log(c);
            // undefined

        Finally, when looking up non-existent properties in an object, you will receive undefined:
            var d = {};
            console.log(d.fake);
            // undefined

        if done null == undefined       // true
        but if done null ===undefined   // false

        if passed to a function where the argument has a default value then passing undefined would use default value whereas null would replace the default value's value.

        Similarities: 
            i) In javascript there are 6 falsy values - false, 0 (zero), “” (empty string), null, undefined, NaN (Not A Number)
                So both null and undefined are falsy values.
            ii) Primitive values in JS - Boolean, null, undefined, String, Number, Symbol
                So both are primitive values
            
21. Function overloading vs Function overriding:
        Javascript does not support function overloading

        Overriding: if you define two functions with the same name, the last one defined will override the previously defined version and every time a call will be made to the function, the last defined one will get executed.

22. Lexical scoping vs Dynamic scoping:
        Scoping is how you search for an element in the document

        Dynamic scope: We start searching as per the call-stack. Call-stack is simply a stack of in what order the interpretor will start searching the file.
            Eg: function greeting() {
                    // [1] Some codes here
                    sayHi();
                    // [2] Some codes here
                }
                function sayHi() {
                    return "Hi!";
                }

                // Invoke the `greeting` function
                greeting();

                // Some codes here

                Flow of how scoping occurs as per call stack
                    i) Ignore all functions, until it reaches the greeting() function invocation.
                    ii) Add the greeting() function to the call stack list.
                    iii) Execute all lines of code inside greeting() function.
                    iv) Get to the sayHi() function invocation.
                    v) Add the sayHi() function to the call-stack list.
                    vi) Execute all lines of code inside the sayHi() function, until reaches its end.
                    vii) Return execution to the line that invoked sayHi() and continue executing the rest of the greeting() function.
                    viii) Delete the sayHi() function from our call-stack list.
                    ix) When everything inside the greeting() function has been executed, return to its invoking line to continue executing the rest of the Javascript code.
                    x) Delete the greeting() function from call-stack list.

        There is no dynamic scoping in Javascript

        Lexical Scope: also called static scope. defines how variable names are resolved inside a nested function. The inner functions contains the scope of the parent functions even if the parent function has returned.

23. Precedence of Operators:

    Associativity: is the order that how the operators of the same precedence will be parsed.
        Left associativity: left to right
        Right associativity: right to left

    Table: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

24. nullish coalescing operator (??): returns right part when left part is undefined or null
    Eg: const foo = null ?? 'default string';
        console.log(foo);
        // expected output: "default string"

        const baz = 0 ?? 42;
        console.log(baz);
        // expected output: 0

25. for..of: strings, array and any other iterable values
    Eg: const iterable = [10, 20, 30];
        for (const value of iterable) {
            console.log(value);
        }
        // 10
        // 20
        // 30

    Eg: Iterating over a Map
        const iterable = new Map([['a', 1], ['b', 2], ['c', 3]]);

        for (const entry of iterable) {
            console.log(entry);
        }
        // ['a', 1]
        // ['b', 2]
        // ['c', 3]

        for (const [key, value] of iterable) {
            console.log(value);
        }
        // 1
        // 2
        // 3

26. for vs forEach() vs for..of vs for..in:
        for (let i = 0; i < arr.length; ++i)
        arr.forEach((v, i) => { /* ... */ })
        for (let i in arr)
        for (const v of arr)

        1)  Syntactical:
            for & for..in gives the index of the element rather than the actual element itself.
            whereas
            for..of & foreach() gives the element itself on each iteration.

        2)  Non-numeric properties:
            Arrays are object so you can add a key value pair in arr as following:
                const arr = ['a', 'b', 'c'];
                typeof arr; // 'object'
                
                // Assign to a non-numeric property
                arr.test = 'bad';

                arr.test; // 'bad'
                arr[1] === arr['1'];
            
                console.log(arr);   // ["a", "b", "c", test: "bad"]

            Only for..in loop will consider the non-numeric property.
                Eg: // Prints "a, b, c, bad"
                    for (let i in arr) {
                        console.log(arr[i]);
                    }
                whereas
            other 3 will ignore the non-numeric property
                Eg: // Prints "a, b, c"
                    for (let i = 0; i < arr.length; ++i) {
                        console.log(arr[i]);
                    }

                    // Prints "a, b, c"
                    arr.forEach((el, i) => console.log(i, el));

                    // Prints "a, b, c"
                    for (const el of arr) {
                        console.log(el);
                    }

        3)  Empty elements:
            Say we have an array ['a',,'c']. ,, is called a hole     //length: 3

            Now loop constructs behave differently for ['a',,'c'] to ['a',undefined,'c'];

            for..in & forEach() simple skip the empty element
                whereas
            for..of & for do not
                Eg: // Prints "a, undefined, c"
                    for (let i = 0; i < arr.length; ++i) {
                        console.log(arr[i]);
                    }

                    // Prints "a, c"
                    arr.forEach(v => console.log(v));

                    // Prints "a, c"
                    for (let i in arr) {
                        console.log(arr[i]);
                    }

                    // Prints "a, undefined, c"
                    for (const v of arr) {
                        console.log(v);
                    }

            There's another way to add an empty element to an array:

            // Equivalent to `['a', 'b', 'c',, 'e']`
            const arr = ['a', 'b', 'c'];
            arr[5] = 'e';

            Moreover holes in javascript are rare as JSON does not support holes.
            $ node
            > JSON.parse('{"arr":["a","b","c"]}')
            { arr: [ 'a', 'b', 'c' ] }
            > JSON.parse('{"arr":["a",null,"c"]}')
            { arr: [ 'a', null, 'c' ] }
            > JSON.parse('{"arr":["a",,"c"]}')
            SyntaxError: Unexpected token , in JSON at position 12

        4)  Function context: Its all about binding to this here.
            for, for..in, for..of retains the outside scope's value of this
            forEach() behaves differently for this and returns undefined. If used with arrow functions then behaves the same like others.

        5)  Async/Await & generators:
            forEach() does not behave good with these. You cant use them in forEach()

27. Currying: Currying is the process of taking a function with multiple arguments and returning a series of functions that take one argument and eventually resolve to a value. The original function volume takes three arguments, but once curried we can instead pass in each argument to three nested functions.
    Eg: multiply(3)(4)(5);

28. Error handling patterns:
    Categories of errors:
        1) Syntax errors: also known as parsing errors
            var x = 2;
            var y = 3;

            console.log(x + y;

            In the example above, the last line of code will cause a syntax error because it is missing a closing parenthesis. Usually when a syntax error occurs in JavaScript, the rest of the code in other threads will get executed if they contain nothing that depends on the code containing the error.

        2) Runtime errors: also known as exceptions
            var windowObject;
            var windowFeatures = "menubar=yes,location=yes,resizable=yes,scrollbars=yes,status=yes";

            function openPopup() {
                windowObject = window.openObject("http://www.bbc.com/", "BBC_WindowName", strWindowFeatures);
            }
            The function above will cause a runtime error because although the syntax is correct, at runtime it is trying to call a method openObject() that doesn’t exist.

        3) Logical Errors: The most complex of all three errors, logical errors occur when you make a mistake or flaw in the logic that controls your program’s script. This mistake causes the program to alter expected results or exhibit unexpected behavior.
            function power(base, exponent) {
                var result = 1;
                for (var count = 0; count < exponent; count++)
                    result *= base;
                return result;
            }
            What if someone tries to call power (``"``JavaScript``"``, 10)? Well that’s obviously a programmer mistake. What about power (5, 0.2)? A quick look at the function’s logic will tell you that it can’t handle fractional exponents but by the law of Mathematics, raising a number to the halfth power is possible.

    Handling errors : We can catch the error through callbacks:
        Eg: var myFunc = function(cb) {
                doSomething(function (err, a) {
                    if (err) return cb(err)
                    doSomethingElse(function (err, b) {
                        if (err) return cb(err)
                        return cb(null, [a, b])
                    })
                })
            }

        To further handle these errors:
            1. try..catch..finally: Only logical & runtime errors can be caught and not syntax errors.
                try {
                    // Code to run
                    [
                    break;
                    ]
                } catch (e) {
                    // Code to run if an exception occurs
                    [
                    break;
                    ]
                }
                [
                    finally {
                    // Code that is always executed regardless of 
                    // an exception occurring
                    }
                ]

                try statements are the statements to be executed. If an exception occurs during the execution of the try statement, the exception is placed in e and the catch clause is executed otherwise, the catch clause is skipped. The finally clause executes after the try statement is finished, it executes regardless of whether or not an exception was thrown or caught

            2. throw statement: It is used to define user-defined exceptions. When a throw statement is encountered then control is passed to catch block and execution of try block stops for the current function. If there is no catch clause, the program will terminate.
            3. The onerror() Method: The onerror() method was the first event handler to facilitate and handle errors in JavaScript. It is often used with the syntax window.onerror. This enables the error event to be fired on the window object whenever an error occurs during runtime.
                Another utility mode for onerror() is using it to display an error message in case there is any error when loading images in your site:
                    <img src="coolPhoto.jpg" onerror="alert('An error occurred loading yor photo.')" />

        Call Stack Property:
            The stack property is a feature in JavaScript Error object. It offers a trace of which functions were called, in what order, from which line and file and with what arguments, proceeding from the most recent calls to earlier ones all the way to the original global scope call.
            Eg: function trace() {
                    try {
                    throw new Error('myError');
                    } catch (e) {
                    alert(e.stack);
                    }
                }

                function b() {
                    trace();
                }

                function a() {
                    b(3, 4, '\n\n', undefined, {});
                }
                a('first call, firstarg');

                Assuming the above markup is saved as C:\stackoverflow.js on a Windows file system it produces an alert message box with the following text:

                trace@file:///C:/stackoverflow.js:4:17
                b@file:///C:/stackoverflow.js:11:13
                a@file:///C:/stackoverflow.js:14:13
                @file:///C:/stackoverflow.js:15:9
                            
            A warning though, stack is a non standard feature. It shouldn’t be used on production sites facing the web as it will not work for every user.

        Handling errors in Asynchronous code:
            We can use promises for this. We can pass a catch block

29. Shadow DOM: 
        DOM: a tree like structure that connects nodes of different elements and strings that appear in a markup document.

        High level view: Shadow DOM allows hidden DOM trees to be attached to normal DOM starting with shadow root.
        
            Some basic terminologies:
                1. Shadow host: The regular DOM node that the shadow DOM is attached to.
                2. Shadow tree: The DOM tree inside the shadow DOM.
                3. Shadow boundary: the place where the shadow DOM ends, and the regular DOM begins.
                4. Shadow root: The root node of the shadow tree.

            We can do changes with Shadow DOM as we do with normal DOM but the only difference is that changes in Shadow DOM won't affect the outer elements, allowing for a handy encapsulation

        Basic Usage:
            let shadow = elementRef.attachShadow({mode: 'open'});
            let shadow = elementRef.attachShadow({mode: 'closed'});

            open means that you can access the shadow DOM using JavaScript written in the main page context, for example using the Element.shadowRoot property:

            let myShadowDom = myCustomElem.shadowRoot;

30. Event bubbling: Event bubbling is when an event will traverse from the most inner nested HTML element and move up the DOM hierarchy until it arrives at the element which listens for the event. This move is also popularly known as Event Propagation or Event Delegation.

31. Regular expressions: Regular expressions are patterns used to match character combinations in strings. In JavaScript, regular expressions are also objects.
    2 ways of using reglar expressions:
        i) let re = /ab+c/;
        ii) let re = new RegExp('ab+c');

    These patterns are used with the exec() and test() methods of RegExp, and with the match(), matchAll(), replace(), search(), and split() methods of String

    Using simple patterns:
        Simple patterns are constructed of characters for which you want to find a direct match. For example, the pattern /abc/ matches character combinations in strings only when the exact sequence "abc" occurs (all characters together and in that order). Such a match would succeed in the strings "Hi, do you know your abc's?" and "The latest airplane designs evolved from slabcraft." In both cases the match is with the substring "abc". There is no match in the string "Grab crab" because while it contains the substring "ab c", it does not contain the exact substring "abc".

    Using special characters:
        When the search for a match requires something more than a direct match, such as finding one or more b's, or finding white space, you can include special characters in the pattern. For example, to match a single "a" followed by zero or more "b"s followed by "c", you'd use the pattern /ab*c/: the * after "b" means "0 or more occurrences of the preceding item." In the string "cbbabbbbcdebc", this pattern will match the substring "abbbbc".

        1. Assertions: Assertions include boundaries, which indicate the beginnings and endings of lines and words
            ^, $, x(?=y), x(?!y), (?<=y)x, (?<!y)x, \b, \B
        2. Character class: Distinguish different types of characters. For example, distinguishing between letters and digits.
            \, ., \cX, \d, \D, \f, \n, \r, \s, \S, \t, \v, \w, \W, \0, \xhh, \uhhhh, \uhhhhh, [\b]
        3. Groups and ranges: Indicate groups and ranges of expression characters.
            (x), (?:x), x|y, [xyz], [^xyz], \Number
        4. Quantifiers: Indicate numbers of characters or expressions to match.
            *, +, ?, x{n}, x{n,}, x{n,m}
        5. Unicode property escapes: Distinguish based on unicode character properties, for example, upper- and lower-case letters, math symbols, and punctuation.
            \p{UnicodeProperty}, \P{UnicodeProperty}

        A cheatsheet is available for the above: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet

    Escaping: If you need to use any of the special characters literally (actually searching for a "*", for instance), you must escape it by putting a backslash in front of it.
        i) For instance, to search for "a" followed by "*" followed by "b", you'd use /a\*b/ — the backslash "escapes" the "*", making it literal instead of special.
        ii) For instance, to search for the string "/example/" followed by one or more alphabetic characters, you'd use /\/example\/[a-z]+/i—the backslashes before each slash make them literal.
        iii) For instance, to match the string "C:\" where "C" can be any letter, you'd use /[A-Z]:\\/ — the first backslash escapes the one after it, so the expression searches for a single literal backslash.
        

    
    Methods that use regular expressions
        Method	            Description
        exec()	            Executes a search for a match in a string. It returns an array of information or null on a mismatch.
        test()	            Tests for a match in a string. It returns true or false.
        match()	            Returns an array containing all of the matches, including capturing groups, or null if no match is found.
        matchAll()	        Returns an iterator containing all of the matches, including capturing groups.
        search()	        Tests for a match in a string. It returns the index of the match, or -1 if the search fails.
        replace()	        Executes a search for a match in a string, and replaces the matched substring with a replacement substring.
        split()	            Uses a regular expression or a fixed string to break a string into an array of substrings.

        Example: var myArray = /d(b+)d/g.exec('cdbbdbsbz'); 
            // similar to "cdbbdbsbz".match(/d(b+)d/g); however,
            // "cdbbdbsbz".match(/d(b+)d/g) outputs Array [ "dbbd" ], while 
            // /d(b+)d/g.exec('cdbbdbsbz') outputs Array [ 'dbbd', 'bb', index: 1, input: 'cdbbdbsbz' ]

    Advanced searching with flags:
        var re = /pattern/flags;
                    or
        var re = new RegExp('pattern', 'flags');

        Note that the flags are an integral part of a regular expression. They cannot be added or removed later.

        Flag	    Description	                                                                                    Corresponding property
        g	        Global search.	                                                                                RegExp.prototype.global
        i	        Case-insensitive search.	                                                                    RegExp.prototype.ignoreCase
        m	        Multi-line search.	                                                                            RegExp.prototype.multiline
        s	        Allows . to match newline characters.	                                                        RegExp.prototype.dotAll
        u	        "unicode"; treat a pattern as a sequence of unicode code points.	                            RegExp.prototype.unicode
        y	        Perform a "sticky" search that matches starting at the current position in the target string.	RegExp.prototype.sticky

32. Declarative vs Imperative programming:
        Declarative programming is a programming paradigm … that expresses the logic of a computation without describing its control flow.
        Imperative programming is a programming paradigm that uses statements that change a program’s state.

33. Polyfill : A polyfill is a piece of code (usually JavaScript on the Web) used to provide modern functionality on older browsers that do not natively support it. ... The polyfill uses non-standard features in a certain browser to give JavaScript a standards-compliant way to access the feature.

34. Higher order functions: A higher order function is a function that takes a function as an argument, or returns a function. Higher order function is in contrast to first order functions, which don’t take a function as an argument or return a function as output.
        Earlier we saw examples of .map() and .filter(). Both of them take a function as an argument. They're both higher order functions.

35. prototype vs __proto__: The prototype is a property on a constructor function that sets what will become the __proto__ property on the constructed object.
    Every object can have another object as its prototype. Then the former object inherits all of its prototype’s properties. An object specifies its prototype via the internal property [[Prototype]]. The chain of objects connected by the [[Prototype]] property is called the prototype chain.
    The __proto__ is an accessor property of the Object.prototype object. It exposes the internal prototype linkage ( [[Prototype]]) of an object through which it is accessed.



